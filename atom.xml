<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifan&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yifanguo.top/"/>
  <updated>2018-07-25T07:33:09.000Z</updated>
  <id>http://www.yifanguo.top/</id>
  
  <author>
    <name>Yifan Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java_concurrent_volatile02</title>
    <link href="http://www.yifanguo.top/2018/07/25/java-concurrent-volatile02/"/>
    <id>http://www.yifanguo.top/2018/07/25/java-concurrent-volatile02/</id>
    <published>2018-07-25T07:04:18.000Z</published>
    <updated>2018-07-25T07:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="volatile">volatile</span></h1><ol><li>保证内存可见性。</li><li>保证排序，不会因为指令重排导致问题</li><li>不保证原子性</li></ol><h1><span id="demo">Demo</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static int flag = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new ThreadA().start();</span><br><span class="line">        new ThreadB().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 线程A进入死循环直到读出变量大于3</span><br><span class="line">    // 会发现线程A永远无法跳出循环，因为flag不是volatile类型变量</span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (flag &gt;= 3) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;in CustomerInLine....&quot; + flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 线程B不停增加flag值，但是jvm会把flag写进cpu cache提升优化</span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (flag &lt; 10) &#123;</span><br><span class="line">                System.out.println(&quot;in Queue ...&quot; + flag++);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(200);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决的办法很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static int flag = 0;</span><br></pre></td></tr></table></figure><h1><span id="指令重排">指令重排</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MainOrder &#123;</span><br><span class="line"></span><br><span class="line">    private static String context = null;</span><br><span class="line">    private static boolean flag;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new MainOrder.ThreadA().start();</span><br><span class="line">        new MainOrder.ThreadB().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           context = &quot;hello word&quot;;</span><br><span class="line">           flag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (!flag) &#123;</span><br><span class="line">                    sleep(100);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(context);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指令重排，threadB会先看到true然后print一个null</p><h1><span id="不保证原子性">不保证原子性</span></h1><p>如果多个线程同时读写一个volatile变量，不保证原子性。<br>使用java concurrent包来解决这个问题，或者加入synchronized声明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;volatile&quot;&gt;volatile&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;保证内存可见性。&lt;/li&gt;
&lt;li&gt;保证排序，不会因为指令重排导致问题&lt;/li&gt;
&lt;li&gt;不保证原子性&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;span id=&quot;demo&quot;&gt;Demo
      
    
    </summary>
    
    
      <category term="concurrent" scheme="http://www.yifanguo.top/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>java_basic_cloneable</title>
    <link href="http://www.yifanguo.top/2018/07/24/java-basic-cloneable/"/>
    <id>http://www.yifanguo.top/2018/07/24/java-basic-cloneable/</id>
    <published>2018-07-25T06:37:28.000Z</published>
    <updated>2018-07-25T06:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="introduction">introduction</span></h1><p>from orcale java doc</p><p>public interface Cloneable<br>A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instances of that class.<br>Invoking Object’s clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown.</p><p>By convention, classes that implement this interface should override Object.clone (which is protected) with a public method. See Object.clone() for details on overriding this method.</p><p>Note that this interface does not contain the clone method. Therefore, it is not possible to clone an object merely by virtue of the fact that it implements this interface. Even if the clone method is invoked reflectively, there is no guarantee that it will succeed.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;introduction&quot;&gt;introduction&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;from orcale java doc&lt;/p&gt;
&lt;p&gt;public interface Cloneable&lt;br&gt;A class implements the Clon
      
    
    </summary>
    
    
      <category term="basic" scheme="http://www.yifanguo.top/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>java_concurrent_volatile</title>
    <link href="http://www.yifanguo.top/2018/07/24/java-concurrent-volatile/"/>
    <id>http://www.yifanguo.top/2018/07/24/java-concurrent-volatile/</id>
    <published>2018-07-25T06:24:57.000Z</published>
    <updated>2018-07-25T06:36:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="overall">Overall</span></h1><ol><li>visibility gurantee</li><li>happens-before gurantee</li></ol><h1><span id="function">Function</span></h1><p>The Java volatile keyword guarantees visibility of changes to variables across threads. </p><p>In a multithreaded application where the threads operate on non-volatile variables, each thread may copy variables from main memory into a CPU cache while working on them, for performance reasons. If your computer contains more than one CPU, each thread may run on a different CPU. That means, that each thread may copy the variables into the CPU cache of different CPUs.</p><p><img src="/Users/yifanguo/Desktop/屏幕快照 2018-07-24 23.25.32.png" alt=""></p><h1><span id="hapen-before">Hapen before</span></h1><p>To address the instruction reordering challenge, the Java volatile keyword gives a “happens-before” guarantee, in addition to the visibility guarantee. The happens-before guarantee guarantees that:</p><p>Reads from and writes to other variables cannot be reordered to occur after a write to a volatile variable, if the reads / writes originally occurred before the write to the volatile variable.<br>The reads / writes before a write to a volatile variable are guaranteed to “happen before” the write to the volatile variable. Notice that it is still possible for e.g. reads / writes of other variables located after a write to a volatile to be reordered to occur before that write to the volatile. Just not the other way around. From after to before is allowed, but from before to after is not allowed.<br>Reads from and writes to other variables cannot be reordered to occur before a read of a volatile variable, if the reads / writes originally occurred after the read of the volatile variable. Notice that it is possible for reads of other variables that occur before the read of a volatile variable can be reordered to occur after the read of the volatile. Just not the other way around. From before to after is allowed, but from after to before is not allowed.</p><h1><span id="when-to-use">when to use</span></h1><p>if two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic</p><p>As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package. For instance, the AtomicLong or AtomicReference or one of the others.</p><p>In case only one thread reads and writes the value of a volatile variable and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable. Without making the variable volatile, this would not be guaranteed.</p><h1><span id="performce">Performce</span></h1><p>Reading from and writing to main memory is more expensive than accessing the CPU cache. Accessing volatile variables also prevent instruction reordering which is a normal performance enhancement technique. Thus, you should only use volatile variables when you really need to enforce visibility of variables.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;overall&quot;&gt;Overall&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;visibility gurantee&lt;/li&gt;
&lt;li&gt;happens-before gurantee&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;span id=&quot;function&quot;&gt;F
      
    
    </summary>
    
    
      <category term="concurrent" scheme="http://www.yifanguo.top/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>netty03--bootstrap</title>
    <link href="http://www.yifanguo.top/2018/07/24/netty03/"/>
    <id>http://www.yifanguo.top/2018/07/24/netty03/</id>
    <published>2018-07-25T04:25:23.000Z</published>
    <updated>2018-07-25T06:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="bootstrap">Bootstrap</span></h1><p>bootstrap makes it easy to bootstrap a channel to use for clients</p><p>link() for udp<br>connect() tcp</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;bootstrap&quot;&gt;Bootstrap&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;bootstrap makes it easy to bootstrap a channel to use for clients&lt;/p&gt;
&lt;p&gt;link() for udp&lt;br&gt;
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty02</title>
    <link href="http://www.yifanguo.top/2018/07/24/netty02/"/>
    <id>http://www.yifanguo.top/2018/07/24/netty02/</id>
    <published>2018-07-25T02:10:05.000Z</published>
    <updated>2018-07-25T03:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="introduction">Introduction</span></h1><p>Netty is an asynchhronous event-driven network application framework<br>for rapid development of maintainable high performance protocal servers&amp;clients<br>–high-scalability protocol servers and clients.</p><p>Netty is an NIO client server framework that enables quick and easy development of network applications such as protocol servers and clients.</p><h1><span id="framework">framework</span></h1><p><img src="/Users/yifanguo/Desktop/屏幕快照 2018-07-24 19.12.41.png" alt=""></p><h1><span id="why-use-netty">why use Netty</span></h1><p>a general purpose protocal or its implementation sometimes does not scale very well</p><h1><span id="protocol">protocol</span></h1><p>Additionally, Netty provides out-of-the-box decoders which enables you to implement most protocols very easily and helps you avoid from ending up with a monolithic unmaintainable handler implementation. Please refer to the following packages for more detailed examples:</p><p>io.netty.example.factorial for a binary protocol, and<br>io.netty.example.telnet for a text line-based protocol.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;introduction&quot;&gt;Introduction&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Netty is an asynchhronous event-driven network application framework&lt;br&gt;for rapid dev
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty分析01 -- 简介</title>
    <link href="http://www.yifanguo.top/2018/07/24/netty01/"/>
    <id>http://www.yifanguo.top/2018/07/24/netty01/</id>
    <published>2018-07-24T09:30:21.000Z</published>
    <updated>2018-07-25T02:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="什么是nettywhat">什么是netty(what)</span></h1><p>Netty 是一个高性能，异步事件驱动的NIO框架，它提供了对TCP,UDP和文件传输的支持</p><p>传统HTTP服务器的原理</p><p>1.创建一个serversocket listen 一个端口</p><ol start="2"><li>client request ip-address/port</li><li>服务器使用accept获得一个来自client的socket连接对象</li><li>启动一个新的thread来处理连接</li><li>读socket 得到byte stream</li><li>解码协议，得到http request</li><li>处理http request, 得到一个结果，封装成http response</li><li>encoing ,把结果序列化 byte stream</li><li>写socket 把byte stream 发送给客户端</li><li>客户端循环第五步</li></ol><p>HTTP服务器之所以叫HTTP,因为encoding 和decoding都是使用HTTP协议<br><strong>使用netty可以定制编解码协议，实现自己特定协议的服务器</strong></p><p>NIO: non-blocking input/output operation 非阻塞io<br>BIO: blocking io<br><strong>netty是基于javaNIO封装的一套框架</strong></p><p>NIO如何做到非阻塞，event driven.只有event coming才启动线程处理，平常挂起避免资源浪费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while true &#123;</span><br><span class="line">events = takeEvents(fds)</span><br><span class="line">for event in events &#123;</span><br><span class="line">if event.isAcceptable &#123;</span><br><span class="line">doAccept()</span><br><span class="line"></span><br><span class="line">&#125; else if event.isReadable &#123;</span><br><span class="line">request = doRead()</span><br><span class="line">if request.isCompelete() &#123;</span><br><span class="line">doPrecess()</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if event.isWriteable &#123;</span><br><span class="line">do write()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 可以处理tcp也可以处理udp</p><h1><span id="netty-是什么">netty 是什么</span></h1><ol><li>本质：JBoss做的一个jar包</li><li>目的： 快速开发高性能，高可靠的网络服务器和客户端程序</li><li>优点：提供异步，事件驱动的网络应用程序框架和工具</li><li>通俗： 帮你处理socket</li></ol><h2><span id="应用">应用：</span></h2><p>RPC框架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;什么是nettywhat&quot;&gt;什么是netty(what)&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Netty 是一个高性能，异步事件驱动的NIO框架，它提供了对TCP,UDP和文件传输的支持&lt;/p&gt;
&lt;p&gt;传统HTTP服务器的原理&lt;/p&gt;
&lt;p&gt;1.创建一个ser
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="http://www.yifanguo.top/2018/07/24/netty00/"/>
    <id>http://www.yifanguo.top/2018/07/24/netty00/</id>
    <published>2018-07-24T09:12:16.000Z</published>
    <updated>2018-07-24T09:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty简介">netty简介</span></h1><p>Netty 是一个高性能，异步事件驱动的NIO框架，它提供了对TCP,UDP和文件传输的支持</p><p>netty的所有IO操作都是异步非阻塞的<br>用过future-listener机制，用户可以方便的主动获取</p><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，接收到客户端连接之后为客户端连接创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，由于线程是JAVA虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能急剧下降，随着并发量的继续增加，可能会发生句柄溢出、线程堆栈溢出等问题，并导致服务器最终宕机</p><h1><span id="序列化方式问题java序列化存在如下几个典型问题">序列化方式问题：Java序列化存在如下几个典型问题：</span></h1><p>1) Java序列化机制是Java内部的一种对象编解码技术，无法跨语言使用；例如对于异构系统之间的对接，Java序列化后的码流需要能够通过其它语言反序列化成原始对象（副本），目前很难支持；</p><p>2) 相比于其它开源的序列化框架，Java序列化后的码流太大，无论是网络传输还是持久化到磁盘，都会导致额外的资源占用；</p><p>3) 序列化性能差（CPU资源占用高）。</p><p>线程模型问题：由于采用同步阻塞IO，这会导致每个TCP连接都占用1个线程，由于线程资源是JVM虚拟机非常宝贵的资源，当IO读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降，严重的甚至会导致虚拟机无法创建新的线程。</p><h1><span id="高性能的三个主题">高性能的三个主题</span></h1><p>1) 传输：用什么样的通道将数据发送给对方，BIO、NIO或者AIO，IO模型在很大程度上决定了框架的性能。</p><p>2) 协议：采用什么样的通信协议，HTTP或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。</p><p>3) 线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor线程模型的不同，对性能的影响也非常大。</p><h1><span id="netty高性能之道">Netty高性能之道</span></h1><h2><span id="异步非阻塞通信">异步非阻塞通信</span></h2><p>在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty简介&quot;&gt;netty简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Netty 是一个高性能，异步事件驱动的NIO框架，它提供了对TCP,UDP和文件传输的支持&lt;/p&gt;
&lt;p&gt;netty的所有IO操作都是异步非阻塞的&lt;br&gt;用过future-listener
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
</feed>
