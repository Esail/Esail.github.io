<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifan Guo Personal Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yifanguo.top/"/>
  <updated>2018-07-31T05:11:36.000Z</updated>
  <id>http://www.yifanguo.top/</id>
  
  <author>
    <name>Yifan Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Atomic</title>
    <link href="http://www.yifanguo.top/2018/07/30/Atomic/"/>
    <id>http://www.yifanguo.top/2018/07/30/Atomic/</id>
    <published>2018-07-31T05:04:50.000Z</published>
    <updated>2018-07-31T05:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="atomicity-optimizations">Atomicity Optimizations</span></h1><p>If multiple threads modify the same memory location concurrently, processors do not guarantee any specific result. </p><h1><span id="lock">Lock</span></h1><p>Load Lock/Store Conditional (LL/SC)41 The LL/SC operations work as a pair where the special load instruction is used to start an transaction and the final store will only succeed if the location has not been modified in the meantime. The store oper- ation indicates success or failure, so the program can repeat its efforts if necessary.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int curval;int newval;do &#123;  curval = LL(var);  newval = curval + addend;&#125; while (SC(var, newval));</span><br></pre></td></tr></table></figure><p>#CAS</p><p>Compare-and-Swap (CAS) This is a ternary operation which writes a value provided as a parameter into an address (the second parameter) only if the cur- rent value is the same as the third parameter value;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int curval;</span><br><span class="line">int newval;</span><br><span class="line">do &#123;</span><br><span class="line">curval = var;</span><br><span class="line">  newval = curval + addend;</span><br><span class="line">&#125; while (CAS(&amp;var, curval, newval));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;atomicity-optimizations&quot;&gt;Atomicity Optimizations&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;If multiple threads modify the same memory location concurrentl
      
    
    </summary>
    
    
      <category term="concurrency" scheme="http://www.yifanguo.top/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>WhatEveryProgrammerShouldKnowAboutMemory</title>
    <link href="http://www.yifanguo.top/2018/07/30/WhatEveryProgrammerShouldKnowAboutMemory/"/>
    <id>http://www.yifanguo.top/2018/07/30/WhatEveryProgrammerShouldKnowAboutMemory/</id>
    <published>2018-07-30T12:25:51.000Z</published>
    <updated>2018-07-31T04:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="超线程">超线程</span></h1><p>refer: <a href="https://www.cnblogs.com/Amaranthus/archive/2013/07/09/3180036.html" target="_blank" rel="noopener">https://www.cnblogs.com/Amaranthus/archive/2013/07/09/3180036.html</a><br>Hyper-threading enables a single processor core to be used for two or more concurrent executions with just a little extra hardware.</p><h1><span id="现代计算机的架构">现代计算机的架构</span></h1><p>主要有两个部分组成，南北桥<br><img src="nsbridge.png" alt=""></p><p>All CPUs (two in the previous example, but there can be more) are connected via a common bus (the Front Side Bus, FSB) to the Northbridge. </p><p>所有的cpu都通过fsb连接到北桥 <strong>fsb已经被qpi淘汰</strong></p><h2><span id="北桥">北桥</span></h2><p>The Northbridge contains, among other things, the memory controller, and its im- plementation determines the type of RAM chips used for the computer. Different types of RAM, such as DRAM, Rambus, and SDRAM, require different memory con- trollers.</p><p>北桥包含了内存控制器，决定了RAM(random access memory)的类型</p><p>To reach all other system devices, the Northbridge must communicate with the Southbridge.<br>为了接触到其他的devices, 北桥必须和南桥通信</p><h2><span id="南桥">南桥</span></h2><p>南桥又被称为  I/O bridge 通过一系列的bus和其他devices通信</p><p>the PCI, PCI Express, SATA, and USB buses are of most importance, but PATA, IEEE 1394, serial, and par- allel ports are also supported by the Southbridge.</p><p>However, today the PCI-E slots are all connected to the Southbridge.</p><p>这样的结构造成了以下的结果</p><p>##所有的data communication 从一个cpu到另一个cpu必须 travel over the same bus used to communicate with the Northbridge.<br><strong>这个已经有所改变，intel最新的多核处理器是通过qpi进行通信的</strong><br>qpi: quick path iterconnect<br><a href="https://www.intel.com/content/www/us/en/io/quickpath-technology/quick-path-interconnect-introduction-paper.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/io/quickpath-technology/quick-path-interconnect-introduction-paper.html</a></p><p>The Intel QuickPath Interconnect (QPI) is a point-to-point processor interconnect developed by Intel which replaced the front-side bus (FSB) in Xeon, Itanium, and certain desktop platforms starting in 2008.  Prior to the name’s announcement, Intel referred to it as Common System Interface (CSI).</p><p>… 2008年推出的技术，结果这篇文章是2007年的</p><p>QPI will be replaced by Intel UltraPath Interconnect (UPI) in future Skylake EX/EP Xeon processors based on LGA 3647 socket.[5]</p><p>QPI也要被淘汰…</p><p>the QuickPath Architecture assumes that the processors will have integrated memory controllers, and enables a non-uniform memory access (NUMA) architecture.</p><h2><span id="all-communication-with-ram-must-pass-through-the-northbridge">All communication with RAM must pass through the Northbridge.</span></h2><h2><span id="the-ram-has-only-a-single-port">The RAM has only a single port</span></h2><h2><span id="communication-between-a-cpu-and-a-device-at-tached-to-the-southbridge-is-routed-through-the-northbridge">Communication between a CPU and a device at- tached to the Southbridge is routed through the Northbridge.</span></h2><h1><span id="dma-direct-memory-access">DMA direct memory access</span></h1><p>DMA allows devices, with the help of the Northbridge, to store and receive data in RAM directly without the intervention of the CPU (and its inherent performance cost). </p><p>it also creates contention for the bandwidth of the Northbridge as DMA requests compete with RAM access from the CPUs.</p><ol><li>DMA允许设备直接和RAM交互</li><li>DMA会和CPU抢夺北桥带宽</li></ol><h1><span id="第二个bottleneck">第二个bottleneck</span></h1><p>recent RAM types require two sep- arate buses (or channels as they are called for DDR2, see page 8) which doubles the available bandwidth.</p><p>北桥和RAM之间的总线所以出现了双通道（可以实现带宽加倍，内存访问在两个通道上交错分配）</p><p>北桥自身不带内存控制器，而是连接到外部多个内存控制器上，好处是支持更多的内存，可以同时访问不同的内存区，降低了延迟，但是对北桥的内部带宽要求巨大。<br>使用外部内存控制器并不是唯一的办法，比较流行的还有一种是把控制器集成到cpu内部，将内存直接连接到CPU<br><img src="nbridge.png" alt=""><br>The advantage of this architecture is that more than one memory bus exists and therefore total available band- width increases</p><p>这样的架构，系统里有几个cpu就可以有几个内存库（memory bank），不需要强大的北桥就可以实现4倍的内存带宽。但是缺点也是很明显：1.导致内存不再是统一的资源（NUMA的得名），2.cpu可以正常的访问本地内存，但是访问其他内存时需要和其他cpu互通。在讨论访问远端内存的代价时，我们用「NUMA因子」这个词。比如说IBM的x445和SGI的Altix系列。CPU被归入节点，节点内的内存访问时间是一致的，或者只有很小的NUMA因子。而在节点之间的连接代价很大，而且有巨大的NUMA因子。</p><p>#CSI<br>Intel will have support for the Common System Interface (CSI) starting with the Nehalem processors; this is basically the same approach: an integrated memory controller with the possibility of local memory for each processor.</p><p>cpu集成RAM</p><p><img src="imc.png" alt=""></p><p>优点：不需要北桥庞大的带宽<br>缺点：memory is not uniform ( numa- non uniform memroy architecture)</p><h1><span id="ram-types">RAM types</span></h1><p>RAM主要分为2类静态RAM，动态RAM，前者速度快，代价搞，后者速度慢代价低</p><p>SRAM 比DRAM 更贵</p><h1><span id="static-ram">static RAM</span></h1><p><img src="SRAM.png" alt=""></p><p>6个二极管组成的static dram</p><p>They have two stable states, representing 0 and 1 respectively. The state is stable as long as power on Vdd is available.</p><p><strong>这张图就充分说明了为什么断电RAM中的内容会消失</strong></p><p>主要有6个晶体管组成，核心是4个晶体管M1-M4,他们有2个稳定状态分别代表0和1</p><p>If access to the state of the cell is needed the word access line WL is raised. This makes the state of the cell imme- diately available for reading on BL and BL. If the cell state must be overwritten the BL and BL lines are first set to the desired values and then WL is raised. Since the outside drivers are stronger than the four transistors (M1 through M4) this allows the old state to be overwritten.</p><h2><span id="sram的特点">SRAM的特点</span></h2><p>• one cell requires six transistors. There are variants with four transistors but they have disadvantages.<br>• maintaining the state of the cell requires constant power.<br>• the cell state is available for reading almost im- mediately once the word access line WL is raised. The signal is as rectangular (changing quickly be- tween the two binary states) as other transistor- controlled signals.<br>• the cell state is stable, no refresh cycles are needed.</p><h1><span id="dynamic-ram">Dynamic RAM</span></h1><p><img src="dram.png" alt=""></p><p>All it consists of is one transistor and one capacitor<br>动态RAM只有一个晶体管和一个电容</p><ol><li>A dynamic RAM cell keeps its state in the capacitor C.</li><li>The transistor M is used to guard the access to the state.</li><li>To read the state of the cell the access line AL is raised;</li><li>this either causes a current to flow on the data line DL or not, depending on the charge in the capacitor.</li><li>To write to the cell the data line DL is appropriately set and then AL is raised for a time long enough to charge or drain the capacitor.</li></ol><p>disadvantages:</p><h2><span id="readiing-the-cell-discharges-the-capacitor">readiing the cell discharges the capacitor</span></h2><p>动态RAM优点是简单，但是缺点是由于读取状态时需要对电容器放电，所以这一过程不能无限重复，不得不在某个点上对它重新充电。更糟糕的是，为了容纳大量单元(现在一般在单个芯片上容纳10的9次方以上的RAM单元)，电容器的容量必须很小(0.000000000000001法拉以下)。这样，完整充电后大约持有几万个电子。即使电容器的电阻很大(若干兆欧姆)，仍然只需很短的时间就会耗光电荷，称为「泄漏」。</p><p><strong>这种泄露就是现在的大部分DRAM芯片每隔64ms就必须进行一次刷新的原因。（附A关于三极管的输入输出特性</strong></p><p>During the refresh cycle no access to the memory is possible since a refresh is simply a memory read operation where the result is discarded.</p><p>For some workloads this overhead might stall up to 50% of the memory accesses </p><h2><span id="a-second-problem-resulting-from-the-tiny-charge-is-that-the-information-read-from-the-cell-is-not-directly-usable">A second problem resulting from the tiny charge is that the information read from the cell is not directly usable.</span></h2><p>The data line must be connected to a sense amplifier which can distinguish between a stored 0 or 1 over the whole range of charges which still have to count as 1.</p><h2><span id="a-third-problem-is-that-reading-a-cell-causes-the-charge-of-the-capacitor-to-be-depleted">A third problem is that reading a cell causes the charge of the capacitor to be depleted.</span></h2><p>This means every read operation must be followed by an operation to recharge the capacitor. </p><h2><span id="高能预警why-sram-is-faster-than-dram">高能预警，why sram is faster than dram</span></h2><p>Unlike the static RAM case where the output is immediately available when the word access line is raised, it will always take a bit of time until the capacitor discharges sufficiently. This delay severely limits how fast DRAM can be.</p><p>因为DRAM把01状态保存在电容里，导致每次读都需要电容放电</p><h2><span id="dram-优势-size">DRAM 优势 –size</span></h2><p>The SRAM cells also need individual power for the transistors maintaining the state.</p><h1><span id="dram-access">DRAM access</span></h1><p>A program selects a memory location using a virtual address</p><p>The processor translates this into a physical address and finally the memory controller selects the RAM chip corresponding to that address.</p><p>Dynamic RAM Schematic</p><p><img src="data.png" alt=""></p><p>de-multiplexier<br><img src="demultiplexer" alt=""></p><p>The memory controller must be able to address each RAM module (collection of RAM chips).</p><h1><span id="sram-vs-dram">SRAM vs DRAM</span></h1><p>SRAM is currently used in CPU caches and on-die where the connections are small and fully under control of the CPU designer.</p><h1><span id="dram-access-technical-details">DRAM Access Technical Details</span></h1><ol><li>In the section introducing DRAM we saw that DRAM chips multiplex the addresses in order to save resources int the form of address pins. </li><li>We also saw that access- ing DRAM cells takes time since the capacitors in those cells do not discharge instantaneously to produce a stable signal</li><li>we also saw that DRAM cells must be refreshed.</li></ol><h1><span id="dram-sdram-and-its-successors-double-data-rate-dram-ddr">DRAM (SDRAM) and its successors Double Data Rate DRAM (DDR).</span></h1><h1><span id="sdram-synchronous-dram">SDRAM - Synchronous DRAM</span></h1><p>同步DRAM，顾名思义，是参照一个时间源工作的。由内存控制器提供一个时钟，时钟的频率决定了前端总线(FSB)的速度。以今天的SDRAM为例，每次数据传输包含64位，即8字节。所以FSB的传输速率应该是有效总线频率乘于8字节(对于4倍传输200MHz总线而言，传输速率为6.4GB/s)。听起来很高，但要知道这只是峰值速率，实际上无法达到的最高速率。我们将会看到，与RAM模块交流的协议有大量时间是处于非工作状态，不进行数据传输。我们必须对这些非工作时间有所了解，并尽量缩短它们，才能获得最佳的性能。</p><h1><span id="221读访问协议">2.2.1读访问协议</span></h1><p>这里忽略了许多细节，我们只关注时钟频率、RAS与CAS信号、地址总线和数据总线。首先，内存控制器将行地址放在地址总线上，并降低RAS信号，读周期开始。所有信号都在时钟(CLK)的上升沿读取，因此，只要信号在读取的时间点上保持稳定，就算不是标准的方波也没有关系。设置行地址会促使RAM芯片锁住指定的行。</p><p>CAS信号在tRCD(RAS到CAS时延)个时钟周期后发出。内存控制器将列地址放在地址总线上，降低CAS线。这里我们可以看到，地址的两个组成部分是怎么通过同一条总线传输的。</p><p>既然数据的传输需要这么多的准备工作，仅仅传输一个字显然是太浪费了。因此，DRAM模块允许内存控制指定本次传输多少数据。可以是2、4或8个字。这样，就可以一次填满高速缓存的整条线，而不需要额外的RAS/CAS序列。另外，内存控制器还可以在不重置行选择的前提下发送新的CAS信号。这样，读取或写入连续的地址就可以变得非常快，因为不需要发送RAS信号，也不需要把行置为非激活状态(见下文)。</p><p>在上图中，SDRAM的每个周期输出一个字的数据。这是第一代的SDRAM。而DDR可以在一个周期中输出两个字。这种做法可以减少传输时间，但无法降低时延。</p><p><img src="address.png" alt=""></p><h1><span id="222预充电和激活">2.2.2预充电和激活</span></h1><p>2.2.1中的图只是读取数据的一部分，还有以下部分：</p><p>显示的是两次CAS信号的时序图。第一次的数据在CL周期后准备就绪。图中的例子里，是在SDRAM上，用两个周期传输了两个字的数据。如果换成DDR的话，则可以传输4个字。即使是在一个命令速率为1的DRAM模块上，也无法立即发出预充电命令，而要等数据传输完成。在上图中，即为两个周期。刚好与CL相同，但只是巧合而已。预充电信号并没有专用线，某些实现是用同时降低写使能(WE)线和RAS线的方式来触发。</p><p>发出预充电信命令后，还需等待tRP(行预充电时间)个周期之后才能使行被选中。在图2.9中，这个时间(紫色部分)大部分与内存传输的时间(淡蓝色部分)重合。不错。但tRP大于传输时间，因此下一个RAS信号只能等待一个周期。</p><p>数据总线的7个周期中只有2个周期才是真正在用的。再用它乘于FSB速度，结果就是，800MHz总线的理论速率6.4GB/s降到了1.8GB/s</p><p>我们会看到预充电指令被数据传输时间限制（途中为COL Addr的传输）除此之外，SDRAM模块在RAS信号之后，需要经过一段时间，才能进行预充电(记为tRAS)（minimum active to precharge time（也就是RAS信号之后到充电的最小时间间隔））它的值很大，一般达到tRP的2到3倍。如果在某个RAS信号之后，只有一个CAS信号，而且数据只传输很少几个周期，那么就有问题了。假设在图2.9中，第一个CAS信号是直接跟在一个RAS信号后免的，而tRAS为8个周期。那么预充电命令还需要被推迟一个周期，因为tRCD、CL和tRP加起来才7个周期。</p><p>DDR模块往往用w-z-y-z-T来表示。例如，2-3-2-8-T1，意思是：</p><p>w 2 CAS时延(CL)<br>x 3 RAS-to-CAS时延(t RCD)<br>y 2 RAS预充电时间(t RP)<br>z 8 激活到预充电时间(t RAS)<br>T T1 命令速率</p><h1><span id="223重充电">2.2.3重充电</span></h1><p>充电对内存是性能最大的影响，根据JEDEC规范，DRAM单元必须保持每64ms刷新一次我们在解读性能参数时有必要知道，它也是DRAM生命周期的一个部分。如果系统需要读取某个重要的字，而刚好它所在的行正在刷新，那么处理器将会被延迟很长一段时间。刷新的具体耗时取决于DRAM模块本身。</p><h1><span id="225-结论">2.2.5 结论</span></h1><p>通过本节，大家应该了解到访问DRAM的过程并不是一个快速的过程。至少与处理器的速度相比，或与处理器访问寄存器及缓存的速度相比，DRAM的访问不算快。大家还需要记住CPU和内存的频率是不同的。Intel Core 2处理器运行在2.933GHz，而1.066GHz FSB有11:1的时钟比率(注: 1.066GHz的总线为四泵总线)。那么，内存总线上延迟一个周期意味着处理器延迟11个周期。绝大多数机器使用的DRAM更慢，因此延迟更大。<br>前文中读命令的时序图表明，DRAM模块可以支持高速数据传输。每个完整行可以被毫无延迟地传输。数据总线可以100%被占。对DDR而言，意味着每个周期传输2个64位字。对于DDR2-800模块和双通道而言，意味着12.8GB/s的速率。</p><p>但是，除非是特殊设计，DRAM的访问并不总是串行的。访问不连续的内存区意味着需要预充电和RAS信号。于是，各种速度开始慢下来，DRAM模块急需帮助。预充电的时间越短，数据传输所受的惩罚越小。</p><p>硬件和软件的预取(参见第6.3节)可以在时序中制造更多的重叠区，降低延迟。预取还可以转移内存操作的时间，从而减少争用。我们常常遇到的问题是，在这一轮中生成的数据需要被存储，而下一轮的数据需要被读出来。通过转移读取的时间，读和写就不需要同时发出了</p><p>2.3主存的其他用户<br>除了CPU外，系统中还有其它一些组件也可以访问主存。高性能网卡或大规模存储控制器是无法承受通过CPU来传输数据的，它们一般直接对内存进行读写(直接内存访问，DMA)。在图2.1中可以看到，它们可以通过南桥和北桥直接访问内存。另外，其它总线，比如USB等也需要FSB带宽，即使它们并不使用DMA，但南桥仍要通过FSB连接到北桥。</p><p>DMA当然有很大的优点，但也意味着FSB带宽会有更多的竞争。在有大量DMA流量的情况下，CPU在访问内存时必然会有更大的延迟。我们可以用一些硬件来解决这个问题。例如，通过图2.3中的架构，我们可以挑选不受DMA影响的节点，让它们的内存为我们的计算服务。还可以在每个节点上连接一个南桥，将FSB的负荷均匀地分担到每个节点上。</p><h1><span id="what-programmer-can-do">what programmer can do</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;超线程&quot;&gt;超线程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;refer: &lt;a href=&quot;https://www.cnblogs.com/Amaranthus/archive/2013/07/09/3180036.html&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="core" scheme="http://www.yifanguo.top/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="http://www.yifanguo.top/2018/07/30/lock/"/>
    <id>http://www.yifanguo.top/2018/07/30/lock/</id>
    <published>2018-07-30T11:46:26.000Z</published>
    <updated>2018-07-30T12:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="深入理解锁机制的实现">深入理解锁机制的实现</span></h1><h1><span id="cas">CAS</span></h1><p>Unsafe中有一个method compareAndSwapInt 实现的是无锁同步的机制<br>我们看下它是如何实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">         * Compares the value of the integer field at the specified offset</span><br><span class="line">         * in the supplied object with the given expected value, and updates</span><br><span class="line">         * it if they match.  The operation of this method should be atomic,</span><br><span class="line">         * thus providing an uninterruptible way of updating an integer field.</span><br><span class="line">         * 在obj的offset位置比较integer field和期望的值，如果相同则更新。这个方法</span><br><span class="line">         * 的操作应该是原子的，因此提供了一种不可中断的方式更新integer field。</span><br><span class="line">         *</span><br><span class="line">         * @param obj the object containing the field to modify.</span><br><span class="line">         *            包含要修改field的对象</span><br><span class="line">         * @param offset the offset of the integer field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line">         *               &lt;code&gt;obj&lt;/code&gt;中整型field的偏移量</span><br><span class="line">         * @param expect the expected value of the field.</span><br><span class="line">         *               希望field中存在的值</span><br><span class="line">         * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line">         *           如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line">         * @return true if the field was changed.</span><br><span class="line">         *                             如果field的值被更改</span><br><span class="line">         */</span><br><span class="line">         </span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>调用了JNI，也就是说有对应的unsafe.cpp的接口 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  //获取对象的变量的地址</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  //调用Atomic操作</span><br><span class="line">  //进入atomic.hpp,大意就是先去获取一次结果，如果结果和现在不同，就直接返回，因为有其他人修改了；否则会一直尝试去修改。直到成功。</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>再来看atomic::cmpxchg这个方法实现，这是一个c++的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123;</span><br><span class="line">  assert(sizeof(jbyte) == 1, &quot;assumption.&quot;);</span><br><span class="line">  uintptr_t dest_addr = (uintptr_t)dest;</span><br><span class="line">  uintptr_t offset = dest_addr % sizeof(jint);</span><br><span class="line">  volatile jint* dest_int = (volatile jint*)(dest_addr - offset);</span><br><span class="line">  jint cur = *dest_int;</span><br><span class="line">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class="line">  jint new_val = cur;</span><br><span class="line">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class="line">  new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  while (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line">    if (res == cur) break;</span><br><span class="line">    cur = res;</span><br><span class="line">    new_val = cur;</span><br><span class="line">    new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  &#125;</span><br><span class="line">  return cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jint* dest_int 做了volatile，意味着值不会从cpu cache中获取，会从主内存中获取</p><p>CAS是Compare And Set的缩写。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><h1><span id="x86">x86</span></h1><p>CAS保证了原子性，<br>原子性定义<br>Atomic Variables. The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. That is, a set has a happens-before relationship with any subsequent get on the same variable.</p><p>简单来说就是原子变量一旦开始操作就不会做context switch（切换到另一个线程），直到运行结束。</p><h2><span id="什么情况下适合用atomic类">什么情况下适合用atomic类</span></h2><p>Atomic classes are designed primarily as building blocks for implementing non-blocking data structures and related infrastructure classes. The compareAndSet method is not a general replacement for locking. It applies only when critical updates for an object are confined to a single variable.</p><p>那么在x86架构中是如何实现的</p><h1><span id="m-threads-同时-sharedcounter">M threads 同时++ sharedCounter</span></h1><p>non-volatile version:<br>add    $0x10,%ecx</p><p>volatile version:<br>mov    0xc(%r10),%r8d ; Load<br>inc    %r8d           ; Increment<br>mov    %r8d,0xc(%r10) ; Store<br>lock addl $0x0,(%rsp) ; StoreLoad Barrier</p><p>makes every store before the lock addl visible to other processors, and ensures that every load after the lock addl gets at least the version visible at the time it is executed. In this case, volatile gives visibility, in that each of the processors immediately gets the version from the other processors after each increment.</p><p>AtomicInteger version:</p><p>mov    0xc(%r11),%eax       ; Load<br>mov    %eax,%r8d<br>inc    %r8d                 ; Increment<br>lock cmpxchg %r8d,0xc(%r11) ; Compare and exchange</p><p>cmpxchg:<br>Compares the value in the EAX register with the destination operand. If the two values are equal, the source operand is loaded into the destination operand. Otherwise, the destination operand is loaded into the EAX register.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;深入理解锁机制的实现&quot;&gt;深入理解锁机制的实现&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;cas&quot;&gt;CAS&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Unsafe中有一个method compareAndSwapInt 实现的是无锁同
      
    
    </summary>
    
    
      <category term="lock" scheme="http://www.yifanguo.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>unix network programming</title>
    <link href="http://www.yifanguo.top/2018/07/30/unix/"/>
    <id>http://www.yifanguo.top/2018/07/30/unix/</id>
    <published>2018-07-30T08:53:18.000Z</published>
    <updated>2018-07-30T09:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="unix-network-programming-learning-notes">unix network programming learning notes</span></h1><p>daemon: 后台程序</p><p>a Web server is typically thought of as a long-running program (or daemon) that sends network messages only in response to requests coming in from the network. The other side of the protocol is a Web client, such as a browser, which always initiates communication with the server. </p><p>Web clients and servers communicate using the Transmission Control Protocol, or TCP. TCP, in turn, uses the Internet Protocol, or IP, and IP communicates with a datalink layer of some form.</p><p><img src="tcp.png" alt=""></p><p>Even though the client and server communicate using an application protocol, the transport layers communicate using TCP</p><p>he client and server need not be attached to the same local area network (LAN) as we show in Figure 1.3. For instance, in Figure 1.4, we show the client and server on different LANs, with both LANs connected to a wide area network (WAN) using routers.</p><p><img src="wan.png" alt=""></p><p>The largest WAN today is the Internet.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;unix-network-programming-learning-notes&quot;&gt;unix network programming learning notes&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;daemon: 后台程序&lt;/p&gt;
&lt;p&gt;a Web serve
      
    
    </summary>
    
    
      <category term="unix" scheme="http://www.yifanguo.top/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>linux_sychronization</title>
    <link href="http://www.yifanguo.top/2018/07/30/linux-sychronization/"/>
    <id>http://www.yifanguo.top/2018/07/30/linux-sychronization/</id>
    <published>2018-07-30T08:41:38.000Z</published>
    <updated>2018-07-30T08:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux中常见同步机制设计原理">Linux中常见同步机制设计原理</span></h1><p>-谈谈linux中常见并发访问的保护机制设计原理</p><h1><span id="自旋锁spin-lock">自旋锁（spin lock）</span></h1><p>自旋锁是linux中使用非常频繁的锁，原理简单。当进程A申请锁成功后，进程B申请锁就会失败，但是不会调度，原地自旋。就在原地转到天昏地暗只为等到进程A释放锁。由于不会睡眠和调度的特性，在中断上下文中，数据的保护一般都是选择自旋锁。如果有多个进程去申请锁。当第一个申请锁成功的线程在释放的时候，其他进程是竞争的关系。因此是一种不公平。所以现在的linux采用的是排队机制。先到先得。谁先申请，谁就先得到锁</p><h2><span id="next-and-owner">next and owner</span></h2><p>linux中针对每一个spin lock会有两个计数。分别是next和owner（初始值为0）。进程A申请锁时，会判断next和owner的值是否相等。如果相等就代表锁可以申请成功，否则原地自旋。直到owner和next的值相等才会退出自旋。假设进程A申请锁成功，然后会next加1。此时owner值为0，next值为1。进程B也申请锁，保存next得值到局部变量tmp（tmp = 1）中。由于next和owner值不相等，因此原地自旋读取owner的值，判断owner和tmp是否相等，直到相等退出自旋状态。当然next的值还是加1，变成2。进程A释放锁，此时会将owner的值加1，那么此时B进程的owner和tmp的值都是1，因此B进程获得锁。当B进程释放锁后，同样会将owner的值加1。最后owner和next都等于2，代表没有进程持有锁。next就是一个记录申请锁的次数，而owner是持有锁进程的计数值。</p><h1><span id="信号量semaphore">信号量（semaphore）</span></h1><p>信号量（semaphore）是进程间通信处理同步互斥的机制。是在多线程环境下使用的一种措施，它负责协调各个进程，以保证他们能够正确、合理的使用公共资源。 它和spin lock最大的不同之处就是：无法获取信号量的进程可以睡眠，因此会导致系统调度。</p><h2><span id="原理">原理</span></h2><p>信号量一般可以用来标记可用资源的个数。老规矩，还是举个例子。假设图书馆有2本《C语言从入门到放弃》书籍。A同学想学C语言，于是发现这本书特别的好。于是就去学校的图书馆借书，A同学成功的从图书馆借走一本。这时，A同学室友B同学发现A同学竟然在偷偷的学习武功秘籍（C语言）。于是，B同学也去借一本。此时，图书馆已经没有书了。C同学也想借这本书，可能是这本书太火了。图书馆管理员告诉C同学，图书馆这本书都被借走了。如果有同学换回来，会第一时间通知你。于是，管理员就把C同学的信息登记先来，以备后续通知C同学来借书。所以，C同学只能悲伤的走了（如果是自旋锁的原理的话，那么C同学将会端个小板凳坐在图书馆，一直要等到A同学或者B同学还书并借走）。</p><h1><span id="读写锁read-write-lock">读写锁（read-write lock）</span></h1><p>不管是自旋锁还是信号量在同一时间只能有一个进程进入临界区。对于有些情况，我们是可以区分读写操作的。因此，我们希望对于读操作的进程可以并发进行。对于写操作只限于一个进程进入临界区。而这种同步机制就是读写锁。读写锁一般具有以下几种性质。<br>同一时间有且仅有一个写进程进入临界区。<br>在没有写进程进入临界区的时候，同时可以有多个读进程进入临界区。<br>读进程和写进程不可以同时进入临界区。<br>读写锁有两种，一种是信号量类型，另一种是spin lock类型。下面以spin lock类型讲解。</p><p>##原理<br>老规矩，还是举个例子理解读写锁。我绞尽脑汁才想到一个比较贴切的例子。这个例子来源于生活。我发现公司一般都会有保洁阿姨打扫厕所。如果以男厕所为例的话，我觉得男士进入厕所就相当于读者进入临界区。因为可以有多个男士进厕所。而保洁阿姨进入男士厕所就相当于写者进入临界区。假设A男士发现保洁阿姨不在打扫厕所，就进入厕所。随后B和C同时也进入厕所。然后保洁阿姨准备打扫厕所，发现有男士在厕所里面，因此只能在门口等待。ABC都离开了厕所。保洁阿姨迅速进入厕所打扫。然后D男士去上厕所，发现保洁阿姨在里面。灰溜溜的出来了在门口等着。现在体会到了写者（保洁阿姨）具有排他性，读者（男士）可以并发进入临界区了吧。</p><p>既然我们允许多个读者进入临界区，因此我们需要一个计数统计读者的个数。同时，由于写者永远只存在一个进入临界区，因此只需要一个bit标记是否有写进程进入临界区。所以，我们可以将两个计数合二为一。只需要1个unsigned int类型即可。最高位（bit31）代表是否有写者进入临界区，低31位（0~30bit）统计读者个数。</p><h1><span id="互斥量mutex">互斥量（mutex）</span></h1><p>前文提到的semaphore在初始化count计数的时候，可以分为计数信号量和互斥信号量（二值信号量）。mutex和初始化计数为1的二值信号量有很大的相似之处。他们都可以用做资源互斥。但是mutex却有一个特殊的地方：只有持锁者才能解锁。但是，二值信号量却可以在一个进程中获取信号量，在另一个进程中释放信号量。如果是应用在嵌入式应用的RTOS，针对mutex的实现还会考虑优先级反转问题。</p><p>原理<br>既然mutex是一种二值信号量，因此就不需要像semaphore那样需要一个count计数。由于mutex具有“持锁者才能解锁”的特点，所以我们需要一个变量owner记录持锁进程。释放锁的时候必须是同一个进程才能释放。当然也需要一个链表头，主要用来便利睡眠等待的进程。原理和semaphore及其相似，因此在代码上也有体现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux中常见同步机制设计原理&quot;&gt;Linux中常见同步机制设计原理&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;-谈谈linux中常见并发访问的保护机制设计原理&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;自旋锁spin-lock&quot;&gt;自旋锁（spin lock）&lt;/span
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.yifanguo.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux_kernel</title>
    <link href="http://www.yifanguo.top/2018/07/30/linux-kernel/"/>
    <id>http://www.yifanguo.top/2018/07/30/linux-kernel/</id>
    <published>2018-07-30T08:21:17.000Z</published>
    <updated>2018-07-30T08:41:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="linux-kernel">linux kernel</span></h1><ol><li><p>Process Scheduler，也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU。</p></li><li><p>Memory Manager，内存管理。负责管理Memory（内存）资源，以便让各个进程可以安全地共享机器的内存资源。另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，需要使用的时候，再取回到内存中。</p></li><li><p>VFS（Virtual File System），虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为可以通过统一的文件操作接口（open、close、read、write等）来访问。这就是Linux系统“一切皆是文件”的体现（其实Linux做的并不彻底，因为CPU、内存、网络等还不是文件，如果真的需要一切皆是文件，还得看贝尔实验室正在开发的”Plan 9”的）。</p></li><li><p>Network，网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准。</p></li><li><p>IPC（Inter-Process Communication），进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信。</p></li></ol><h1><span id="process-scheduler">Process Scheduler</span></h1><p>进程调度是Linux内核中最重要的子系统，它主要提供对CPU的访问控制。因为在计算机中，CPU资源是有限的，而众多的应用程序都要使用CPU资源，所以需要“进程调度子系统”对CPU进行调度管理。</p><p><img src="linux.png" alt=""></p><ol><li><p>Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有CPU。</p></li><li><p>Architecture-specific Schedulers，体系结构相关的部分，用于将对不同CPU的控制，抽象为统一的接口。这些控制主要在suspend和resume进程时使用，牵涉到CPU的寄存器访问、汇编指令操作等。</p></li><li><p>Architecture-independent Scheduler，体系结构无关的部分。它会和“Scheduling Policy模块”沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers模块”resume指定的进程。</p></li><li><p>System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。</p></li></ol><h1><span id="memory-manager">Memory Manager</span></h1><p><img src="mm.png" alt=""></p><ol><li><p>Architecture Specific Managers，体系结构相关部分。提供用于访问硬件Memory的虚拟接口。</p></li><li><p>Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的memory mapping；虚拟内存的Swapping。</p></li><li><p>System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的map等功能。</p></li></ol><h1><span id="虚拟文件系统virtual-filesystem-vfs">虚拟文件系统（Virtual Filesystem, VFS）</span></h1><p><img src="vfs.png" alt=""></p><ol><li><p>Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux内核中将近一半的Source Code都是设备驱动，大多数的Linux底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是Linux内核的精髓所在）。</p></li><li><p>Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。</p></li><li><p>Logical Systems，每一种文件系统，都会对应一个Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。</p></li><li><p>System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。</p></li><li><p>System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。</p></li></ol><h1><span id="网络子系统net">网络子系统（Net）</span></h1><p><img src="net.png" alt=""></p><ol><li><p>Network Device Drivers，网络设备的驱动，和VFS子系统中的设备驱动是一样的。</p></li><li><p>Device Independent Interface，和VFS子系统中的是一样的。</p></li><li><p>Network Protocols，实现各种网络传输协议，例如IP, TCP, UDP等等。</p></li><li><p>Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。</p></li><li><p>System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。</p></li></ol><h1><span id="linux内核源代码的目录结构">Linux内核源代码的目录结构</span></h1><ol><li><p>内核核心代码，包括第3章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等</p></li><li><p>其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p></li><li><p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;linux-kernel&quot;&gt;linux kernel&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Process Scheduler，也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.yifanguo.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>dubboRpc</title>
    <link href="http://www.yifanguo.top/2018/07/29/dubboRpc/"/>
    <id>http://www.yifanguo.top/2018/07/29/dubboRpc/</id>
    <published>2018-07-30T04:51:28.000Z</published>
    <updated>2018-07-30T04:51:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="rpc" scheme="http://www.yifanguo.top/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>rxjava</title>
    <link href="http://www.yifanguo.top/2018/07/29/rxjava/"/>
    <id>http://www.yifanguo.top/2018/07/29/rxjava/</id>
    <published>2018-07-30T03:56:42.000Z</published>
    <updated>2018-07-30T04:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="backpressure">backpressure</span></h1><p>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。</p><h1><span id="observer-pattern">Observer pattern</span></h1><p>RxJava 以观察者模式为骨架<br>Observable ( 被观察者 ) / Observer ( 观察者 )<br>Flowable （被观察者）/ Subscriber （观察者）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;backpressure&quot;&gt;backpressure&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;observer
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>vertxDemos</title>
    <link href="http://www.yifanguo.top/2018/07/29/vertxDemos/"/>
    <id>http://www.yifanguo.top/2018/07/29/vertxDemos/</id>
    <published>2018-07-30T02:53:32.000Z</published>
    <updated>2018-07-30T02:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="几个vertx搭建的demo">几个vertx搭建的demo</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;几个vertx搭建的demo&quot;&gt;几个vertx搭建的demo&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>vertx.io</title>
    <link href="http://www.yifanguo.top/2018/07/29/vertx-io/"/>
    <id>http://www.yifanguo.top/2018/07/29/vertx-io/</id>
    <published>2018-07-30T01:35:29.000Z</published>
    <updated>2018-07-30T02:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="what-is-vertx">what is vertx</span></h1><p>vertx is a toolkit to build reactive and distributed system</p><h1><span id="reactive-system-principles">reactive system principles</span></h1><p>responsive, elastic , resilient, asynchronous message passing to interact</p><h1><span id="what-is-reactive">what is reactive</span></h1><p>Reactive programming—A development model focusing on the observation of data streams, reacting on changes, and propagating them</p><p>Reactive system—An architecture style used to build responsive and robust distributed systems based on asynchronous message-passing</p><p>Reactive streams is an initiative to provide a standard for asynchronous stream processing with back-pressure. It provides a minimal set of interfaces and protocols that describe the opera‐ tions and entities to achieve the asynchronous streams of data with nonblocking back-pressure. It does not define operators manipulat‐ ing the streams, and is mainly used as an interoperability layer. This initiative is supported by Netflix, Lightbend, and Red Hat, among others.</p><h1><span id="why-use-asynchronous-message-passing">why use asynchronous message-passing</span></h1><p>Using asynchronous message-passing interactions provides reactive systems with two critical properties:<br>• Elasticity—The ability to scale horizontally (scale out/in)<br>• Resilience—The ability to handle failure and recover</p><h1><span id="reactive-microservices">reactive microservices</span></h1><p>##Autonomy<br>They can adapt to the avail‐ ability or unavailability of the services surrounding them. </p><p>##Asynchronisity<br>A reactive microservice uses asynchronous message- passing to interact with its peers. It also receives messages and has the ability to produce responses to these messages.</p><p>• Resilience<br>Resilience is not only about managing failure, it’s also about self-healing</p><p>• Elasticity<br>a reactive microservice must be elastic, so the system can adapt to the number of instances to manage the load.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;what-is-vertx&quot;&gt;what is vertx&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;vertx is a toolkit to build reactive and distributed system&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;react
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent Package API</title>
    <link href="http://www.yifanguo.top/2018/07/27/concurrency/"/>
    <id>http://www.yifanguo.top/2018/07/27/concurrency/</id>
    <published>2018-07-27T09:47:40.000Z</published>
    <updated>2018-08-01T03:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="java-concurrent-package-api">Java Concurrent Package API</span></h1><h1><span id="synchronized">Synchronized</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public top.yifan.synchronizedDemos.Test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public void test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter</span><br><span class="line">       4: aload_1</span><br><span class="line">       5: monitorexit</span><br><span class="line">       6: goto          14</span><br><span class="line">       9: astore_2</span><br><span class="line">      10: aload_1</span><br><span class="line">      11: monitorexit</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: athrow</span><br><span class="line">      14: return</span><br><span class="line">    Exception table:</span><br></pre></td></tr></table></figure><p>可以看到synchronized 由monitorenter和monitorexit 控制， 这确保只有一个线程可以访问critical section</p><h1><span id="juc结构">JUC结构</span></h1><p><img src="juc.png" alt=""></p><h1><span id="aqs-abstractqueuedsynchronizer">AQS (abstractQueuedSynchronizer)</span></h1><p>这是一个framework,被N多java concurrent API 调用<br>先看官方解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Provides a framework for implementing blocking locks and related</span><br><span class="line">* synchronizers (semaphores, events, etc) that rely on</span><br><span class="line">* first-in-first-out (FIFO) wait queues.</span><br></pre></td></tr></table></figure><p>给同步器提供一个fifo的队列</p><p>This class is designed to<br>be a useful basis for most kinds of synchronizers that rely on a<br>single atomic {@code int} value to represent state.</p><p>同步器依赖单个的原子变量，如countDownLatch</p><h1><span id="latch-闭锁">Latch (闭锁）</span></h1><ol><li>确保所有资源都初始化后再执行thread</li><li>确保某个服务在其依赖的服务都启动后再执行</li><li>等待某个操作的所有参与者都准备就绪后再执行</li></ol><p>latch就是阀门的意思，门没打开前，所有线程都将等待</p><h1><span id="countdownlatch">CountDownLatch</span></h1><p><img src="countDownLatch" alt=""></p><p>使一个或多个线程等待一组事件发生<br>包括一个计数器，初始化是一个正数表示需要等待的event数量</p><p>countDown递减计数器，await方法等待计数器达到0</p><p>来看源代码<br>A synchronization aid that allows one or more threads to wait until<br>a set of operations being performed in other threads completes.</p><p>This is a one-shot phenomenon<br>– the count cannot be reset.  If you need a version that resets the<br>count, consider using a {@link CyclicBarrier}.</p><p>CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p><p>虽然，CountDownlatch与CyclicBarrier有那么点相似，但是他们还是存在一些区别的：</p><p>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待</p><p>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier</p><p>自旋尝试获取state</p><h2><span id="await">await</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 对于CountDownLatch而言，如果计数器值不等于0，那么r 会一直小于0</span><br><span class="line">                     */</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //等待</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="countdown">countDown()</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取锁状态</span><br><span class="line">            int c = getState();</span><br><span class="line">            //c == 0 直接返回，释放锁成功</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            //计算新“锁计数器”</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            //更新锁状态（计数器）</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1><span id="unsafe-instances">Unsafe instances</span></h1><h2><span id="锁不一致">锁不一致</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ListHelper&lt;E&gt; &#123;</span><br><span class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">    //list 上的锁 不是listHelper上的锁，所以putIfAbsent相对于list其它的操作并不是thread-safe</span><br><span class="line">    </span><br><span class="line">    public synchronized boolean putIfAbsent(E x) &#123;</span><br><span class="line">        boolean absent = !list.contains(x);</span><br><span class="line">        if (absent) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ListHelper&lt;E&gt; &#123;</span><br><span class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">    //list 上的锁 不是listHelper上的锁，所以putIfAbsent相对于list其它的操作并不是thread-safe</span><br><span class="line">    </span><br><span class="line">    public boolean putIfAbsent(E x) &#123;</span><br><span class="line">      synchronized(list) &#123;</span><br><span class="line">        boolean absent = !list.contains(x);</span><br><span class="line">        if (absent) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的做法是学习synchronizedCollections 对每一个方法都加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 3053995032091335093L;</span><br><span class="line"></span><br><span class="line">        final Collection&lt;E&gt; c;  // Backing Collection</span><br><span class="line">        final Object mutex;     // Object on which to synchronize</span><br><span class="line"></span><br><span class="line">        SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">            this.c = Objects.requireNonNull(c);</span><br><span class="line">            mutex = this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123;</span><br><span class="line">            this.c = Objects.requireNonNull(c);</span><br><span class="line">            this.mutex = Objects.requireNonNull(mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.contains(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public Object[] toArray() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toArray();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toArray(a);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return c.iterator(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean containsAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.containsAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.addAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean removeAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.removeAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean retainAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.retainAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            synchronized (mutex) &#123;c.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toString();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Override default methods in Collection</span><br><span class="line">        @Override</span><br><span class="line">        public void forEach(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">            synchronized (mutex) &#123;c.forEach(consumer);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.removeIf(filter);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return c.spliterator(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Stream&lt;E&gt; stream() &#123;</span><br><span class="line">            return c.stream(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">            return c.parallelStream(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        private void writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">            synchronized (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1><span id="concurrentmap">ConcurrentMap</span></h1><p>采用了分段锁，一种更细粒度的加锁机制 （locking striping)</p><p>Concurrent带来更高的吞吐量，单线程情况下只牺牲了很小的性能</p><p>ConcurrentMap的iterator不会抛出ConcurrentModificationException</p><p>只有程序需要独占map时才放弃concurrentMap</p><p>详情请阅读另一篇java collections详解</p><h1><span id="concurrentmodificationexception">ConcurrentModificationException</span></h1><p>如果容器在迭代的过程中被其他线程修改了，会抛出这个异常</p><p>可以克隆容器，将迭代在副本上进行<br>克隆过程仍然需要加锁</p><p>参考copyonwriteCollections系列</p><h1><span id="operating-system">Operating System</span></h1><ol><li>为各个独立执行的进程分配各种资源包括内存，文件句柄，安全证书等</li><li>不同进程之间可以进行粗粒度的通信，socket, signal processor, shared memory, 信号量和文件</li></ol><h1><span id="thread">Thread</span></h1><p><a href="https://blog.csdn.net/u012398362/article/details/51475213" target="_blank" rel="noopener">https://blog.csdn.net/u012398362/article/details/51475213</a></p><ol><li>线程会共享进程范围内的资源，内存句柄，文件句柄</li><li>线程有各自的程序计数器，stack和局部变量（一组寄存器 存local variables)</li><li>同一个程序的多个thread可以被同时调度到多个cpu上运行</li><li>线程也被称为轻量级进程 是最基本的调度单元</li><li>进程是系统分配资源的基本单位，线程时调度CPU的基本单位</li><li>线程间的切换代价要比进程切换的代价小</li></ol><h1><span id="thread-security">thread security</span></h1><ol><li>对共享的 shared 和mutable可变的 状态进行管理</li></ol><h1><span id="三种同步方式">三种同步方式</span></h1><ol><li>不在线程之间共享该状态 threadlocal</li><li>将状态变量改为不可变 final</li><li>访问时 使用同步机制 synchronized </li></ol><h1><span id="nio">NIO</span></h1><p>non-blocking i/o复杂性远远大于 i/o<br>即使客户端很多，在很多平台线程创建上限也很高，完全可以让每个客户端都拥有一个自己的线程</p><p>所以netty并不一定适合所有的系统</p><h1><span id="context-switch-上下文切换">Context Switch （上下文切换）</span></h1><p>当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销<br>保存和恢复上下文使cpu花更多的时间在线程调度上。</p><h1><span id="同步机制">同步机制</span></h1><p>当线程共享数据时，必须使用同步机制，这些机制会抑制某些编译器的油画，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量</p><p><strong>一个线程只能在一个cpu socket上运行？？</strong> 这句是对的 出自《java并发实战》<br><strong>jvm能不能够将单个线程安排到不同的cpu上去运行呢？</strong> 不可以 jvm可以把多个线程安排到多个cpu上</p><p>在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制</p><h1><span id="intrinsic-lock">intrinsic lock</span></h1><p>每一个java object都可以用作一个实现同步的锁 这种锁称为内置锁或者monitor lock</p><p>sychronized (lock) {</p><p>}</p><h1><span id="private-lock">private lock</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PrivateLock &#123;</span><br><span class="line">    private final Object myLock = new Object();</span><br><span class="line">    Object widget;</span><br><span class="line">    </span><br><span class="line">    void someMethod() &#123;</span><br><span class="line">        synchronized (myLock) &#123;</span><br><span class="line">            // visit widget</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java synchronizedCollection也使用了 monitor pattern<br>优点 封装了锁，客户代码无法通过共有方法获取到lock</p><h1><span id="volatile">volatile</span></h1><ol><li>volatile声明的变量不会被缓存到寄存器中，简而言之，就是volatitle变量的load一定会去main memory中查询</li><li>volatile禁止了重排序</li><li>不保证同步</li><li>只能保证可见性，lock还可以保证原子性</li></ol><h1><span id="publish-and-escape">publish and escape</span></h1><p>有点看不懂…</p><h1><span id="线程封闭-threadlocal">线程封闭 threadlocal</span></h1><p>ThreadLocal<t> 可以被视为 Map&lt;Thread, T&gt;  </t></p><h1><span id="final-and-private">final and Private</span></h1><p>除非需要某个field是mutable的 否则都声明为final<br>除非需要更高的可见性，否则应将所有field都声明为private</p><h1><span id="cas-compareandswapint">CAS-compareAndSwapInt</span></h1><p>Unsafe中有一个method compareAndSwapInt 实现的是无锁同步的机制<br>我们看下它是如何实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">         * Compares the value of the integer field at the specified offset</span><br><span class="line">         * in the supplied object with the given expected value, and updates</span><br><span class="line">         * it if they match.  The operation of this method should be atomic,</span><br><span class="line">         * thus providing an uninterruptible way of updating an integer field.</span><br><span class="line">         * 在obj的offset位置比较integer field和期望的值，如果相同则更新。这个方法</span><br><span class="line">         * 的操作应该是原子的，因此提供了一种不可中断的方式更新integer field。</span><br><span class="line">         *</span><br><span class="line">         * @param obj the object containing the field to modify.</span><br><span class="line">         *            包含要修改field的对象</span><br><span class="line">         * @param offset the offset of the integer field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line">         *               &lt;code&gt;obj&lt;/code&gt;中整型field的偏移量</span><br><span class="line">         * @param expect the expected value of the field.</span><br><span class="line">         *               希望field中存在的值</span><br><span class="line">         * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line">         *           如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line">         * @return true if the field was changed.</span><br><span class="line">         *                             如果field的值被更改</span><br><span class="line">         */</span><br><span class="line">         </span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>调用了JNI，也就是说有对应的unsafe.cpp的接口 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  //获取对象的变量的地址</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  //调用Atomic操作</span><br><span class="line">  //进入atomic.hpp,大意就是先去获取一次结果，如果结果和现在不同，就直接返回，因为有其他人修改了；否则会一直尝试去修改。直到成功。</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>再来看atomic::cmpxchg这个方法实现，这是一个c++的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123;</span><br><span class="line">  assert(sizeof(jbyte) == 1, &quot;assumption.&quot;);</span><br><span class="line">  uintptr_t dest_addr = (uintptr_t)dest;</span><br><span class="line">  uintptr_t offset = dest_addr % sizeof(jint);</span><br><span class="line">  volatile jint* dest_int = (volatile jint*)(dest_addr - offset);</span><br><span class="line">  jint cur = *dest_int;</span><br><span class="line">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class="line">  jint new_val = cur;</span><br><span class="line">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class="line">  new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  while (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line">    if (res == cur) break;</span><br><span class="line">    cur = res;</span><br><span class="line">    new_val = cur;</span><br><span class="line">    new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  &#125;</span><br><span class="line">  return cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jint* dest_int 做了volatile，意味着值不会从cpu cache中获取，会从主内存中获取</p><p>CAS是Compare And Set的缩写。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>1.原语由若干条指令组成的，用于完成一定功能的一个过程。</p><p>2、即原语的执行必须是连续的，在执行过程中不允许被中断。</p><p>在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀’LOCK’，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p><h1><span id="memory-barrier">memory barrier</span></h1><p>内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p><p>内存屏障（memory barrier）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p><h1><span id="bus-locking">Bus locking</span></h1><h2><span id="from-intel-manual-volume-3">from Intel Manual, Volume 3</span></h2><p>Intel 64 and IA-32 processors provide a LOCK# signal that is asserted automatically during certain critical memory operations to lock the system bus or equivalent link. While this output signal is asserted, requests from other processors or bus agents for control of the bus are blocked. Software can specify other occasions when the LOCK semantics are to be followed by prepending the LOCK prefix to an instruction.</p><h1><span id="unsafe">Unsafe</span></h1><p>Unsafe API大部分方法都是native实现（不是java实现的），<br>unsafe是cpp 实现，本质上是cpp的new和delete</p><p>Synchronization：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** @deprecated */</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">/** @deprecated */</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public native void putOrderedInt(Object var1, long var2, int var4);</span><br></pre></td></tr></table></figure><p>Memory:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native long allocateMemory(long var1);</span><br><span class="line">public native long reallocateMemory(long var1, long var3);</span><br><span class="line">public native void setMemory(Object var1, long var2, long var4, byte var6);</span><br><span class="line">public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);</span><br></pre></td></tr></table></figure><h1><span id="native">native</span></h1><p>The native keyword is applied to a method to indicate that the method is implemented in native code using JNI (Java Native Interface).</p><p>It marks a method, that it will be implemented in other languages, not in Java. It works together with JNI (Java Native Interface).</p><h1><span id="cas">CAS</span></h1><p>(compare and set) – nonblockingAlgorithm</p><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><p>总线加锁：总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p><p>缓存加锁：其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p><h2><span id="cas缺陷">CAS缺陷</span></h2><p>循环时间太长</p><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><p>只能保证一个共享变量原子操作</p><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><p><strong>ABA问题</strong></p><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>CAS的ABA隐患问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。对于上面的案例应该线程1会失败。</p><p>以下例子充分说明了ABA问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        atomicInteger = new AtomicInteger(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //AtomicInteger</span><br><span class="line">        Thread at1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                atomicInteger.compareAndSet(100,110);</span><br><span class="line">                atomicInteger.compareAndSet(110,100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread at2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      // at1,执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        at1.start();</span><br><span class="line">        at2.start();</span><br><span class="line"></span><br><span class="line">        at1.join();</span><br><span class="line">        at2.join();</span><br><span class="line"></span><br><span class="line">        //AtomicStampedReference</span><br><span class="line"></span><br><span class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //让 tsf2先获取stamp，导致预期时间戳不一致</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1</span><br><span class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int stamp = atomicStampedReference.getStamp();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tsf1.start();</span><br><span class="line">        tsf2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下面的这个程序，多线程计数器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp</span><br><span class="line">&#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    public synchronized void upateVisitors() </span><br><span class="line">    &#123;</span><br><span class="line">       ++count; //increment the visitors count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证了可见性，原子性，但是牺牲了delay和overhead.这个牺牲非常大，详情见 Is multi-threading really worth it?</p><p>为了解决这个问题，原子结构被introduced</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp</span><br><span class="line">&#123;</span><br><span class="line">    private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">    public void upateVisitors() </span><br><span class="line">    &#123;</span><br><span class="line">       count.incrementAndGet(); //increment the visitors count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS does not make use of locking rather it is very optimistic in nature.<br>It follows these steps:</p><ol><li><p>Compare the value of the primitive to the value we have got in hand.</p></li><li><p>If the values do not match it means some thread in between has changed the value. Else it will go ahead and swap the value with new value.</p></li></ol><h2><span id="is-multi-threading-really-worth-it">Is multi-threading really worth it?</span></h2><p>多线程的目的是最大限度的利用cpu资源</p><p>超线程技术本质上是把进程的线程 映射到不同的cpu core上</p><h2><span id="context-switch">context switch</span></h2><p>作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，为了让用户感觉这些任务正在同时进行，操作系统的设计者巧妙地利用了时间片轮转的方式，CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载，这段过程就叫做上下文切换</p><h2><span id="single-thread-vs-multi-threads">single thread vs multi threads</span></h2><p>适合单线程的场景：单个线程的工作逻辑简单，而且速度非常快，比如从内存中读取某个值，或者从Hash表根据key获得某个value。Redis和Node.js这类程序都是单线程，适合单个线程简单快速的场景。</p><p>适合多线程的场景：单个线程的工作逻辑复杂，等待时间较长或者需要消耗大量系统运算资源，比如需要从多个远程服务获得数据并计算，或者图像处理.</p><h1><span id="synchronized-可重入锁">synchronized (可重入锁）</span></h1><p>每个object创建时都有一个monitor</p><p>Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a “monitor.”) </p><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol><h2><span id="locks-in-synchronized-methods">locks in synchronized methods</span></h2><p>when a thread invokes a synchronized method, it automatically acquires the instrinsic lock for that method’s object and releases it when the method returns</p><h2><span id="重点">重点</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MsLunch &#123;</span><br><span class="line">    private long c1 = 0;</span><br><span class="line">    private long c2 = 0;</span><br><span class="line">    private Object lock1 = new Object();</span><br><span class="line">    private Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">    public void inc1() &#123;</span><br><span class="line">        synchronized(lock1) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inc2() &#123;</span><br><span class="line">        synchronized(lock2) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="reentrant-synchronization">Reentrant Synchronization</span></h2><p>Recall that a thread cannot acquire a lock owned by another thread. But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p><h1><span id="synchronized和lock">synchronized和lock</span></h1><h2><span id="synchronized-的局限性">synchronized 的局限性</span></h2><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性，例如：</p><p>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。<br>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p><h2><span id="lock">Lock</span></h2><p>API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void lock();</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line">boolean tryLock();</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">void unlock();</span><br><span class="line">Condition newCondition();</span><br></pre></td></tr></table></figure><h2><span id="lock使用方式需要手动释放锁">lock使用方式，需要手动释放锁</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock();  可重入锁</span><br><span class="line"> </span><br><span class="line">public void test()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        doSomeThing();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        // ignored</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="aqs">AQS</span></h2><p>AbstractQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。</p><p>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。如图</p><p><img src="aqs.png" alt=""></p><p>AQS中还有一个表示状态的字段state，例如ReentrantLock用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。</p><p>AbstractQueuedSynchronizer继承了AbstractOwnableSynchronizer，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。</p><p>理解AQS可以帮助我们更好的理解JCU包中的同步容器。</p><h2><span id="lock的类型">lock的类型</span></h2><p>可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。<br>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。<br>公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。<br>CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h1><h2><span id="from-oracle">from oracle</span></h2><p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</p><p>This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don’t want to synchronize traversals, yet need to preclude interference among concurrent threads. </p><h2><span id="from-google-serach">from google serach</span></h2><p>This is a very useful construct in the multi-threaded programs – when we want to iterate over a list in a thread-safe way without an explicit synchronization.</p><p>When we are using any of the modify methods – such as add() or remove() – the whole content of the CopyOnWriteArrayList is copied into the new internal copy.</p><h2><span id="when-to-use-it">when to use it</span></h2><p>dont want to synchronize the traversal operations </p><h2><span id="diff-with-readwritelock">diff with  ReadWriteLock</span></h2><p>CopyOnWriteArrayList is for safe traversals.</p><p>ReadWriteLock would allow multiple readers and still let the occasional writer perform the necessary modifications. </p><h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.ConcurrentModificationException;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class CopyOnWriteArrayListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList = new ArrayList&lt;&gt;();</span><br><span class="line">        empList.add(&quot;yifan&quot;);</span><br><span class="line">        empList.add(&quot;guo&quot;);</span><br><span class="line">        empList.add(&quot;smith&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; empIter = empList.iterator();</span><br><span class="line"></span><br><span class="line">        while(empIter.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(empIter.next());</span><br><span class="line">                if (!empList.contains(&quot;lala&quot;)) empList.add(&quot;lala&quot;);</span><br><span class="line">            &#125; catch (ConcurrentModificationException cme) &#123;</span><br><span class="line">                System.err.println(&quot;attempt to modifiy list during iteration&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList2 = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        empList2.add(&quot;yifan&quot;);</span><br><span class="line">        empList2.add(&quot;guo&quot;);</span><br><span class="line">        empList2.add(&quot;smith&quot;);</span><br><span class="line">        empIter = empList2.iterator();</span><br><span class="line">        while (empIter.hasNext()) &#123;</span><br><span class="line">            System.out.println(empIter.next());</span><br><span class="line">            if (!empList2.contains(&quot;Tom Smith&quot;))</span><br><span class="line">                empList2.add(&quot;Tom Smith&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="transient">transient</span></h1><p>The transient keyword in Java is used to indicate that a field should not be serialized.</p><h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class demo implements Serializable &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private transient String middleName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public demo (String fName, String mName, String lName)&#123;</span><br><span class="line">        this.firstName = fName;</span><br><span class="line">        this.middleName = mName;</span><br><span class="line">        this.lastName = lName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(40);</span><br><span class="line">        sb.append(&quot;First Name : &quot;);</span><br><span class="line">        sb.append(this.firstName);</span><br><span class="line">        sb.append(&quot;Middle Name : &quot;);</span><br><span class="line">        sb.append(this.middleName);</span><br><span class="line">        sb.append(&quot;Last Name : &quot;);</span><br><span class="line">        sb.append(this.lastName);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        demo nameStore = new demo(&quot;Steve&quot;, &quot;Middle&quot;,&quot;Jobs&quot;);</span><br><span class="line">        ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;nameStore&quot;));</span><br><span class="line">        // writing to object</span><br><span class="line">        o.writeObject(nameStore);</span><br><span class="line">        o.close();</span><br><span class="line"></span><br><span class="line">        // reading from object</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;nameStore&quot;));</span><br><span class="line">        demo d = (demo)in.readObject();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="reentrant-lock-可重入锁">Reentrant lock (可重入锁）</span></h1><p>synchronized 也是可重入锁</p><p>2.可中断锁</p><p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>　　3.公平锁</p><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。设置方法如下：ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);</p><h1><span id="readwritelock">ReadWriteLock</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;java-concurrent-package-api&quot;&gt;Java Concurrent Package API&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;synchronized&quot;&gt;Synchronized&lt;/spa
      
    
    </summary>
    
    
      <category term="concurrency" scheme="http://www.yifanguo.top/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java Virtual Machine Learning Notes</title>
    <link href="http://www.yifanguo.top/2018/07/26/JVM01/"/>
    <id>http://www.yifanguo.top/2018/07/26/JVM01/</id>
    <published>2018-07-27T01:36:22.000Z</published>
    <updated>2018-07-30T07:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="the-structure-of-jvm">The Structure of JVM</span></h1><h1><span id="the-class-file-format">the class file format</span></h1><ol><li>Compiled code is in binary format </li><li>stored in a file known as the class file format</li><li>it precisely defines the representation of a class or interface</li><li>it includes details such as byte ordering</li></ol><h1><span id="data-types">data types</span></h1><ol><li>primitive types – primitive values</li><li>reference types – reference values</li><li>all type checking is done prior to run time, by compiler not JVM</li><li>An object is either a dynamically allocated class instance or an array</li><li>A reference to an object is considered to have JVM type reference</li><li>values of type referecence can be thought of as pointers to objects</li></ol><h1><span id="primitive-types-and-values">primitive types and values</span></h1><ol><li>the primitive data types supported by JVM are : numeric types , boolean types, returnAddress type</li><li>numeric types consist of integral types and floating-pointing types</li></ol><h2><span id="numeric-types">numeric types</span></h2><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">size</th><th style="text-align:left">range</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">8-bit</td><td style="text-align:left">-128 to 127</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">16 bit</td><td style="text-align:left">-32768 to 32767</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">32bit</td><td style="text-align:left">-2147483648 to 2147483647</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">64bit</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">16bit</td><td style="text-align:left">0 to 65535 inclusive</td></tr></tbody></table><p>default  char: the null code point (‘\u0000’)</p><h2><span id="floating-pointing-types">floating-pointing types:</span></h2><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">size</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">32 bit</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">64 bit</td></tr></tbody></table><h2><span id="boolean-types-true-or-false">boolean types true or false</span></h2><p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.<br>The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).</p><h2><span id="returnaddress-type">returnAddress type</span></h2><p>The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Of the primitive types, only the returnAddress type is not directly associated with a Java programming language type.</p><p>The returnAddress type is used by the Java Virtual Machine’s jsr, ret, and jsr_w instructions (§jsr, §ret, §jsr_w).</p><p>The values of the returnAddress type are pointers to the opcodes(operation codes) of Java Virtual Machine instructions.</p><h1><span id="reference-types-and-values">Reference types and values</span></h1><p>There are three kinds of reference types:<br>class types,<br>array types,<br>and interface types. </p><p>Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</p><p>The default value of a reference type is null.</p><h1><span id="run-time-data-areas">Run-time data areas</span></h1><p>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p><h2><span id="the-pc-register">the pc register</span></h2><ol><li>The Java Virtual Machine can support many threads of execution at once</li><li>each jvm thread has its own pc(program counter) register</li><li>At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread</li><li>if not native method,  pc contains the address of JVM instruction being executed</li><li>if native method, pc is undefined(null)</li></ol><h2><span id="the-jvm-stack">the JVM stack</span></h2><ol><li>each JVM thread has a private JVM stack</li><li>created as the same time as the thread</li><li>it holds local variables and partial results, and plays a part in method invocation and return</li></ol><p>• If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</p><p>• If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</p><h2><span id="heap">HEAP</span></h2><ol><li>heap is shared among all jvm threads</li><li>The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li><li>created on virtual machine start-up. </li><li>heap storage for objects is reclaimed by GC</li><li>objects are never explicitly deallocated</li><li>The memory for the heap does not need to be contiguous.</li></ol><p>• If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.</p><h2><span id="method-area">method area</span></h2><ol><li><p>shared among all threads</p></li><li><p>stores per-class structures such as<br><strong>the run-time constant pool</strong><br><strong>field and method data</strong><br><strong>the code for methods and constructors</strong></p></li><li><p>created on jvm start-up</p></li><li>Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.</li></ol><p>• If memory in the method area cannot be made available to satisfy an allocation<br>request, the Java Virtual Machine throws an OutOfMemoryError.</p><h2><span id="run-time-constant-pool">Run-Time Constant Pool</span></h2><ol><li>A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file</li><li>the run-time constant pool for a class or interface is constructed when the class or interface is created (§5.3) by the Java Virtual Machine.</li><li>part of method area</li></ol><h2><span id="native-method-stacks">Native Method Stacks</span></h2><h1><span id="frame">Frame</span></h1><p>A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p><p>A new frame is created each time a method is invoked. </p><p>A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception)</p><p>frames are allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame.</p><p>Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the run- time constant pool (§2.5.5) of the class of the current method.</p><h2><span id="local-variable">local variable</span></h2><p>Each frame (§2.6) contains an array of variables known as its local variables.</p><p>Local variables are addressed by indexing.</p><p>The Java Virtual Machine uses local variables to pass parameters on method invocation. </p><h2><span id="operand-stacks">operand stacks</span></h2><p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. The operand stack is also used to prepare parameters to be passed to methods and to receive method results.</p><h2><span id="dynamic-linking">dynamic linking</span></h2><p>Each frame (§2.6) contains a reference to the run-time constant pool (§2.5.5) for the type of the current method to support dynamic linking of the method code.</p><h1><span id="exceptions">Exceptions</span></h1><p>An exception in the Java Virtual Machine is represented by an instance of the class Throwable or one of its subclasses. </p><p>Throwing an exception results in an immediate nonlocal transfer of control from the point where the exception was thrown.</p><h2><span id="exception-handler">exception handler</span></h2><p>An exception handler specifies the range of offsets into the Java Virtual Machine code implementing the method for which the exception handler is active, describes the type of exception that the exception handler is able to handle, and specifies the location of the code that is to handle that exception</p><p>When an exception is thrown, the Java Virtual Machine searches for a matching exception handler in the current method. If a matching exception handler is found, the system branches to the exception handling code specified by the matched handler.</p><h2><span id="instruction-set-summary">instruction set summary</span></h2><p>A Java Virtual Machine instruction consists of a one-byte opcode specifying the operation to be performed, followed by zero or more operands supplying arguments or data that are used by the operation.</p><p> i for an int operation, l for long, s for short, b for byte, c for char, f for float, d for double, and a for reference.</p><p> Given the Java Virtual Machine’s one-byte opcode size, encoding types into opcodes places pressure on the design of its instruction set. </p><p> The only integer operations that can throw an exception are the integer divide instructions (idiv and ldiv) and the integer remainder instructions (irem and lrem), which throw an ArithmeticException if the divisor is zero.</p><h1><span id="object-creation-and-manipulation">Object Creation and Manipulation</span></h1><ol><li>both class instances and arrays are objects,</li><li>creates and manipulates class instances and arrays using distinct sets of instructions:</li><li>Create a new class instance: new.</li><li>Access fields of classes (static fields, known as class variables) and fields of class instances (non-static fields, known as instance variables): getstatic, putstatic, getfield, putfield.</li><li>Check properties of class instances or arrays: instanceof, checkcast.</li></ol><h1><span id="synchironization">Synchironization</span></h1><p>synchronization construct: the monitor.</p><p>When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. </p><p>During the time the executing thread owns the monitor, no other thread may enter it.</p><p>Synchronization of sequences of instructions is typically used to encode the synchronized block of the Java programming language.</p><p>The Java Virtual Machine supplies the monitorenter and monitorexit instructions to support such language constructs. </p><p>Note that the monitor entry and exit automatically performed by the Java Virtual Machine when invoking a synchronized method are considered to occur during the calling method’s invocation.</p><h1><span id="compiling">Compiling</span></h1><p>Compiler transfer java code into instruction set of the jvm</p><p>Just-in-time code generator(JIT)<br>Note that the term “compiler” is sometimes used when referring to a translator from the instruction set of a Java Virtual Machine to the instruction set of a specific CPU. </p><h1><span id="synchironization">Synchironization</span></h1><p>Synchronization in the Java Virtual Machine is implemented by monitor entry and exit</p><h1><span id="the-class-file-format">the class file format</span></h1><p><img src="theClassFile.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;the-structure-of-jvm&quot;&gt;The Structure of JVM&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;the-class-file-format&quot;&gt;the class file format&lt;
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yifanguo.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>cglib</title>
    <link href="http://www.yifanguo.top/2018/07/25/cglib/"/>
    <id>http://www.yifanguo.top/2018/07/25/cglib/</id>
    <published>2018-07-26T06:08:40.000Z</published>
    <updated>2018-07-26T06:54:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cglib-code-generation-library">cglib – code generation library</span></h1><p>it is a byte instrumentation library used in many java framework such as hibernate or spring</p><p>the bytecode instrumentation allows manipulating or creating classes after the compilation phase of a program</p><h1><span id="function">function</span></h1><p>Classes in Java are loaded dynamically at runtime. Cglib is using this feature of Java language to make it possible to add new classes to an already running Java program.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;cglib-code-generation-library&quot;&gt;cglib – code generation library&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;it is a byte instrumentation library used in many
      
    
    </summary>
    
    
      <category term="cglib" scheme="http://www.yifanguo.top/tags/cglib/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper.md</title>
    <link href="http://www.yifanguo.top/2018/07/25/zookeeper-md/"/>
    <id>http://www.yifanguo.top/2018/07/25/zookeeper-md/</id>
    <published>2018-07-26T04:41:20.000Z</published>
    <updated>2018-07-26T06:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="overview">Overview</span></h1><p>ZooKeeper is a distributed, open-source coordination service for distributed applications.</p><h1><span id="purpose">Purpose</span></h1><p>Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;overview&quot;&gt;Overview&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;ZooKeeper is a distributed, open-source coordination service for distributed applications.&lt;/p
      
    
    </summary>
    
    
      <category term="zookeeper" scheme="http://www.yifanguo.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>netty源码解读</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty源码解读/</id>
    <published>2018-07-26T01:33:49.000Z</published>
    <updated>2018-07-26T01:33:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty学习笔记Chapter08</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Chapter08/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记Chapter08/</id>
    <published>2018-07-25T15:23:24.000Z</published>
    <updated>2018-07-25T15:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="chapter8">Chapter8</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;chapter8&quot;&gt;Chapter8&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记Chapter6</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Chapter6/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记Chapter6/</id>
    <published>2018-07-25T11:36:24.000Z</published>
    <updated>2018-07-25T15:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="chapter-6">chapter 6</span></h1><p>java序列化的目的主要有两个：</p><ol><li>网络传输</li><li>对象持久化</li></ol><p>java序列化从jdk1.1就已经提供，只需要implements java.io.Serializable并生成序列id就可以<br>但是rpc很少使用java序列化来进行消息的encoding 和decoding</p><p>原因</p><ol><li>无法跨语言</li><li>序列化后码流太大</li></ol><p>评判编解码框架优劣<br>1 是否支持跨语言<br>2 编码后的码流大小<br>3 编解码的性能<br>4 类库是否小巧，API使用是否方便<br>5 使用者需要手工快发的工作量和难度</p><h1><span id="业界主流的编解码框架">业界主流的编解码框架</span></h1><h2><span id="google的protobuf">Google的protobuf</span></h2><p>它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的pojo对象和protobuf相关的方法和属性</p><ol><li>结构化数据存储格式 xml json</li><li>高效的encoding decoding性能</li><li>语言无关，平台无关，扩展性好</li><li>支持java c++ python</li></ol><h2><span id="facebook的thrift">Facebook的Thrift</span></h2><ol><li>语言系统以及IDL编译器，负责由用户给定的IDL文件生成相应语言的接口代码</li><li>Tprotocol: rpc协议层，可以选择多种不同的对象序列化方式 如json 和binary</li><li>TTransport： RPC传输层，可以选择不同的传输层实现 如socket, NIO. memoryBuffer</li><li>TProcessor: 做为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口</li><li>TServer: 聚合TProtocol, TTransport, TProcessor等对象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;chapter-6&quot;&gt;chapter 6&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;java序列化的目的主要有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络传输&lt;/li&gt;
&lt;li&gt;对象持久化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java序列化从jdk1.1就已经提供，只需要impl
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter5</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter5/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter5/</id>
    <published>2018-07-25T10:30:47.000Z</published>
    <updated>2018-07-25T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty-chapter5">netty chapter5</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty-chapter5&quot;&gt;netty chapter5&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter4</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter4/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter4/</id>
    <published>2018-07-25T09:55:32.000Z</published>
    <updated>2018-07-25T10:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty-chapter4">netty chapter4</span></h1><p>TCP底层并不了解上层业务数据的具体含义<br>它会根据tcp缓冲区的实际情况进行包的划分<br>所以一个完整的包可能会被tcp拆分成多个包进行发送<br>也有可能把多个小的包封装成一个大的数据包发送<br>这就是tcp 粘包和拆包的问题</p><h1><span id="问题产生的原因">问题产生的原因</span></h1><ol><li>application write写入的字节大小大于socket发送缓冲区的大小</li><li>进行mss大小的tcp分段</li><li>以太网帧的payload大于mtu进行ip分片</li></ol><p><img src="/Users/yifanguo/Desktop/屏幕快照 2018-07-25 03.23.27.png" alt=""></p><p>这个问题只能通过上层的应用协议stack来解决</p><ol><li>消息定长，每个msg大小为固定的200byte,如果不够，空位补空格</li><li>在包尾增加回车换行符进行分割 FTP协议</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32表示消息的总长度</li><li>更复杂的应用层协议</li></ol><h1><span id="netty如何解决">netty如何解决</span></h1><p>LinebasedFrameDecoder + Stringdecoder 文本格式的解码器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty-chapter4&quot;&gt;netty chapter4&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;TCP底层并不了解上层业务数据的具体含义&lt;br&gt;它会根据tcp缓冲区的实际情况进行包的划分&lt;br&gt;所以一个完整的包可能会被tcp拆分成多个包进行发送&lt;br&gt;也有可
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter3</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter3/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter3/</id>
    <published>2018-07-25T09:40:57.000Z</published>
    <updated>2018-07-25T09:41:07.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
</feed>
