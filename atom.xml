<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifan Guo Personal Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yifanguo.top/"/>
  <updated>2018-07-30T09:06:21.000Z</updated>
  <id>http://www.yifanguo.top/</id>
  
  <author>
    <name>Yifan Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unix network programming</title>
    <link href="http://www.yifanguo.top/2018/07/30/unix/"/>
    <id>http://www.yifanguo.top/2018/07/30/unix/</id>
    <published>2018-07-30T08:53:18.000Z</published>
    <updated>2018-07-30T09:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="unix-network-programming-learning-notes">unix network programming learning notes</span></h1><p>daemon: 后台程序</p><p>a Web server is typically thought of as a long-running program (or daemon) that sends network messages only in response to requests coming in from the network. The other side of the protocol is a Web client, such as a browser, which always initiates communication with the server. </p><p>Web clients and servers communicate using the Transmission Control Protocol, or TCP. TCP, in turn, uses the Internet Protocol, or IP, and IP communicates with a datalink layer of some form.</p><p><img src="tcp.png" alt=""></p><p>Even though the client and server communicate using an application protocol, the transport layers communicate using TCP</p><p>he client and server need not be attached to the same local area network (LAN) as we show in Figure 1.3. For instance, in Figure 1.4, we show the client and server on different LANs, with both LANs connected to a wide area network (WAN) using routers.</p><p><img src="wan.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;unix-network-programming-learning-notes&quot;&gt;unix network programming learning notes&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;daemon: 后台程序&lt;/p&gt;
&lt;p&gt;a Web serve
      
    
    </summary>
    
    
      <category term="unix" scheme="http://www.yifanguo.top/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>linux_sychronization</title>
    <link href="http://www.yifanguo.top/2018/07/30/linux-sychronization/"/>
    <id>http://www.yifanguo.top/2018/07/30/linux-sychronization/</id>
    <published>2018-07-30T08:41:38.000Z</published>
    <updated>2018-07-30T08:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux中常见同步机制设计原理">Linux中常见同步机制设计原理</span></h1><p>-谈谈linux中常见并发访问的保护机制设计原理</p><h1><span id="自旋锁spin-lock">自旋锁（spin lock）</span></h1><p>自旋锁是linux中使用非常频繁的锁，原理简单。当进程A申请锁成功后，进程B申请锁就会失败，但是不会调度，原地自旋。就在原地转到天昏地暗只为等到进程A释放锁。由于不会睡眠和调度的特性，在中断上下文中，数据的保护一般都是选择自旋锁。如果有多个进程去申请锁。当第一个申请锁成功的线程在释放的时候，其他进程是竞争的关系。因此是一种不公平。所以现在的linux采用的是排队机制。先到先得。谁先申请，谁就先得到锁</p><h2><span id="next-and-owner">next and owner</span></h2><p>linux中针对每一个spin lock会有两个计数。分别是next和owner（初始值为0）。进程A申请锁时，会判断next和owner的值是否相等。如果相等就代表锁可以申请成功，否则原地自旋。直到owner和next的值相等才会退出自旋。假设进程A申请锁成功，然后会next加1。此时owner值为0，next值为1。进程B也申请锁，保存next得值到局部变量tmp（tmp = 1）中。由于next和owner值不相等，因此原地自旋读取owner的值，判断owner和tmp是否相等，直到相等退出自旋状态。当然next的值还是加1，变成2。进程A释放锁，此时会将owner的值加1，那么此时B进程的owner和tmp的值都是1，因此B进程获得锁。当B进程释放锁后，同样会将owner的值加1。最后owner和next都等于2，代表没有进程持有锁。next就是一个记录申请锁的次数，而owner是持有锁进程的计数值。</p><h1><span id="信号量semaphore">信号量（semaphore）</span></h1><p>信号量（semaphore）是进程间通信处理同步互斥的机制。是在多线程环境下使用的一种措施，它负责协调各个进程，以保证他们能够正确、合理的使用公共资源。 它和spin lock最大的不同之处就是：无法获取信号量的进程可以睡眠，因此会导致系统调度。</p><h2><span id="原理">原理</span></h2><p>信号量一般可以用来标记可用资源的个数。老规矩，还是举个例子。假设图书馆有2本《C语言从入门到放弃》书籍。A同学想学C语言，于是发现这本书特别的好。于是就去学校的图书馆借书，A同学成功的从图书馆借走一本。这时，A同学室友B同学发现A同学竟然在偷偷的学习武功秘籍（C语言）。于是，B同学也去借一本。此时，图书馆已经没有书了。C同学也想借这本书，可能是这本书太火了。图书馆管理员告诉C同学，图书馆这本书都被借走了。如果有同学换回来，会第一时间通知你。于是，管理员就把C同学的信息登记先来，以备后续通知C同学来借书。所以，C同学只能悲伤的走了（如果是自旋锁的原理的话，那么C同学将会端个小板凳坐在图书馆，一直要等到A同学或者B同学还书并借走）。</p><h1><span id="读写锁read-write-lock">读写锁（read-write lock）</span></h1><p>不管是自旋锁还是信号量在同一时间只能有一个进程进入临界区。对于有些情况，我们是可以区分读写操作的。因此，我们希望对于读操作的进程可以并发进行。对于写操作只限于一个进程进入临界区。而这种同步机制就是读写锁。读写锁一般具有以下几种性质。<br>同一时间有且仅有一个写进程进入临界区。<br>在没有写进程进入临界区的时候，同时可以有多个读进程进入临界区。<br>读进程和写进程不可以同时进入临界区。<br>读写锁有两种，一种是信号量类型，另一种是spin lock类型。下面以spin lock类型讲解。</p><p>##原理<br>老规矩，还是举个例子理解读写锁。我绞尽脑汁才想到一个比较贴切的例子。这个例子来源于生活。我发现公司一般都会有保洁阿姨打扫厕所。如果以男厕所为例的话，我觉得男士进入厕所就相当于读者进入临界区。因为可以有多个男士进厕所。而保洁阿姨进入男士厕所就相当于写者进入临界区。假设A男士发现保洁阿姨不在打扫厕所，就进入厕所。随后B和C同时也进入厕所。然后保洁阿姨准备打扫厕所，发现有男士在厕所里面，因此只能在门口等待。ABC都离开了厕所。保洁阿姨迅速进入厕所打扫。然后D男士去上厕所，发现保洁阿姨在里面。灰溜溜的出来了在门口等着。现在体会到了写者（保洁阿姨）具有排他性，读者（男士）可以并发进入临界区了吧。</p><p>既然我们允许多个读者进入临界区，因此我们需要一个计数统计读者的个数。同时，由于写者永远只存在一个进入临界区，因此只需要一个bit标记是否有写进程进入临界区。所以，我们可以将两个计数合二为一。只需要1个unsigned int类型即可。最高位（bit31）代表是否有写者进入临界区，低31位（0~30bit）统计读者个数。</p><h1><span id="互斥量mutex">互斥量（mutex）</span></h1><p>前文提到的semaphore在初始化count计数的时候，可以分为计数信号量和互斥信号量（二值信号量）。mutex和初始化计数为1的二值信号量有很大的相似之处。他们都可以用做资源互斥。但是mutex却有一个特殊的地方：只有持锁者才能解锁。但是，二值信号量却可以在一个进程中获取信号量，在另一个进程中释放信号量。如果是应用在嵌入式应用的RTOS，针对mutex的实现还会考虑优先级反转问题。</p><p>原理<br>既然mutex是一种二值信号量，因此就不需要像semaphore那样需要一个count计数。由于mutex具有“持锁者才能解锁”的特点，所以我们需要一个变量owner记录持锁进程。释放锁的时候必须是同一个进程才能释放。当然也需要一个链表头，主要用来便利睡眠等待的进程。原理和semaphore及其相似，因此在代码上也有体现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux中常见同步机制设计原理&quot;&gt;Linux中常见同步机制设计原理&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;-谈谈linux中常见并发访问的保护机制设计原理&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;自旋锁spin-lock&quot;&gt;自旋锁（spin lock）&lt;/span
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.yifanguo.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux_kernel</title>
    <link href="http://www.yifanguo.top/2018/07/30/linux-kernel/"/>
    <id>http://www.yifanguo.top/2018/07/30/linux-kernel/</id>
    <published>2018-07-30T08:21:17.000Z</published>
    <updated>2018-07-30T08:41:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="linux-kernel">linux kernel</span></h1><ol><li><p>Process Scheduler，也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU。</p></li><li><p>Memory Manager，内存管理。负责管理Memory（内存）资源，以便让各个进程可以安全地共享机器的内存资源。另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，需要使用的时候，再取回到内存中。</p></li><li><p>VFS（Virtual File System），虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为可以通过统一的文件操作接口（open、close、read、write等）来访问。这就是Linux系统“一切皆是文件”的体现（其实Linux做的并不彻底，因为CPU、内存、网络等还不是文件，如果真的需要一切皆是文件，还得看贝尔实验室正在开发的”Plan 9”的）。</p></li><li><p>Network，网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准。</p></li><li><p>IPC（Inter-Process Communication），进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信。</p></li></ol><h1><span id="process-scheduler">Process Scheduler</span></h1><p>进程调度是Linux内核中最重要的子系统，它主要提供对CPU的访问控制。因为在计算机中，CPU资源是有限的，而众多的应用程序都要使用CPU资源，所以需要“进程调度子系统”对CPU进行调度管理。</p><p><img src="linux.png" alt=""></p><ol><li><p>Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有CPU。</p></li><li><p>Architecture-specific Schedulers，体系结构相关的部分，用于将对不同CPU的控制，抽象为统一的接口。这些控制主要在suspend和resume进程时使用，牵涉到CPU的寄存器访问、汇编指令操作等。</p></li><li><p>Architecture-independent Scheduler，体系结构无关的部分。它会和“Scheduling Policy模块”沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers模块”resume指定的进程。</p></li><li><p>System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。</p></li></ol><h1><span id="memory-manager">Memory Manager</span></h1><p><img src="mm.png" alt=""></p><ol><li><p>Architecture Specific Managers，体系结构相关部分。提供用于访问硬件Memory的虚拟接口。</p></li><li><p>Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的memory mapping；虚拟内存的Swapping。</p></li><li><p>System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的map等功能。</p></li></ol><h1><span id="虚拟文件系统virtual-filesystem-vfs">虚拟文件系统（Virtual Filesystem, VFS）</span></h1><p><img src="vfs.png" alt=""></p><ol><li><p>Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux内核中将近一半的Source Code都是设备驱动，大多数的Linux底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是Linux内核的精髓所在）。</p></li><li><p>Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。</p></li><li><p>Logical Systems，每一种文件系统，都会对应一个Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。</p></li><li><p>System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。</p></li><li><p>System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。</p></li></ol><h1><span id="网络子系统net">网络子系统（Net）</span></h1><p><img src="net.png" alt=""></p><ol><li><p>Network Device Drivers，网络设备的驱动，和VFS子系统中的设备驱动是一样的。</p></li><li><p>Device Independent Interface，和VFS子系统中的是一样的。</p></li><li><p>Network Protocols，实现各种网络传输协议，例如IP, TCP, UDP等等。</p></li><li><p>Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。</p></li><li><p>System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。</p></li></ol><h1><span id="linux内核源代码的目录结构">Linux内核源代码的目录结构</span></h1><ol><li><p>内核核心代码，包括第3章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等</p></li><li><p>其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p></li><li><p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;linux-kernel&quot;&gt;linux kernel&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Process Scheduler，也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.yifanguo.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>dubboRpc</title>
    <link href="http://www.yifanguo.top/2018/07/29/dubboRpc/"/>
    <id>http://www.yifanguo.top/2018/07/29/dubboRpc/</id>
    <published>2018-07-30T04:51:28.000Z</published>
    <updated>2018-07-30T04:51:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="rpc" scheme="http://www.yifanguo.top/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>rxjava</title>
    <link href="http://www.yifanguo.top/2018/07/29/rxjava/"/>
    <id>http://www.yifanguo.top/2018/07/29/rxjava/</id>
    <published>2018-07-30T03:56:42.000Z</published>
    <updated>2018-07-30T04:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="backpressure">backpressure</span></h1><p>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。</p><h1><span id="observer-pattern">Observer pattern</span></h1><p>RxJava 以观察者模式为骨架<br>Observable ( 被观察者 ) / Observer ( 观察者 )<br>Flowable （被观察者）/ Subscriber （观察者）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;backpressure&quot;&gt;backpressure&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;observer
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>vertxDemos</title>
    <link href="http://www.yifanguo.top/2018/07/29/vertxDemos/"/>
    <id>http://www.yifanguo.top/2018/07/29/vertxDemos/</id>
    <published>2018-07-30T02:53:32.000Z</published>
    <updated>2018-07-30T02:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="几个vertx搭建的demo">几个vertx搭建的demo</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;几个vertx搭建的demo&quot;&gt;几个vertx搭建的demo&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>vertx.io</title>
    <link href="http://www.yifanguo.top/2018/07/29/vertx-io/"/>
    <id>http://www.yifanguo.top/2018/07/29/vertx-io/</id>
    <published>2018-07-30T01:35:29.000Z</published>
    <updated>2018-07-30T02:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="what-is-vertx">what is vertx</span></h1><p>vertx is a toolkit to build reactive and distributed system</p><h1><span id="reactive-system-principles">reactive system principles</span></h1><p>responsive, elastic , resilient, asynchronous message passing to interact</p><h1><span id="what-is-reactive">what is reactive</span></h1><p>Reactive programming—A development model focusing on the observation of data streams, reacting on changes, and propagating them</p><p>Reactive system—An architecture style used to build responsive and robust distributed systems based on asynchronous message-passing</p><p>Reactive streams is an initiative to provide a standard for asynchronous stream processing with back-pressure. It provides a minimal set of interfaces and protocols that describe the opera‐ tions and entities to achieve the asynchronous streams of data with nonblocking back-pressure. It does not define operators manipulat‐ ing the streams, and is mainly used as an interoperability layer. This initiative is supported by Netflix, Lightbend, and Red Hat, among others.</p><h1><span id="why-use-asynchronous-message-passing">why use asynchronous message-passing</span></h1><p>Using asynchronous message-passing interactions provides reactive systems with two critical properties:<br>• Elasticity—The ability to scale horizontally (scale out/in)<br>• Resilience—The ability to handle failure and recover</p><h1><span id="reactive-microservices">reactive microservices</span></h1><p>##Autonomy<br>They can adapt to the avail‐ ability or unavailability of the services surrounding them. </p><p>##Asynchronisity<br>A reactive microservice uses asynchronous message- passing to interact with its peers. It also receives messages and has the ability to produce responses to these messages.</p><p>• Resilience<br>Resilience is not only about managing failure, it’s also about self-healing</p><p>• Elasticity<br>a reactive microservice must be elastic, so the system can adapt to the number of instances to manage the load.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;what-is-vertx&quot;&gt;what is vertx&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;vertx is a toolkit to build reactive and distributed system&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;react
      
    
    </summary>
    
    
      <category term="reactive" scheme="http://www.yifanguo.top/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>concurrency</title>
    <link href="http://www.yifanguo.top/2018/07/27/concurrency/"/>
    <id>http://www.yifanguo.top/2018/07/27/concurrency/</id>
    <published>2018-07-27T09:47:40.000Z</published>
    <updated>2018-07-30T07:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="java-concurrent-package-api">Java Concurrent Package API</span></h1><h1><span id="cascompare-and-set-nonblockingalgorithm">CAS(compare and set) – nonblockingAlgorithm</span></h1><p>来看下面的这个程序，多线程计数器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp</span><br><span class="line">&#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    public synchronized void upateVisitors() </span><br><span class="line">    &#123;</span><br><span class="line">       ++count; //increment the visitors count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证了可见性，原子性，但是牺牲了delay和overhead</p><h2><span id="is-multi-threading-really-worth-it">Is multi-threading really worth it?</span></h2><p>多线程的目的是最大限度的利用cpu资源</p><p>超线程技术本质上是把进程的线程 映射到不同的cpu core上</p><h2><span id="context-switch">context switch</span></h2><p>作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，为了让用户感觉这些任务正在同时进行，操作系统的设计者巧妙地利用了时间片轮转的方式，CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载，这段过程就叫做上下文切换</p><h2><span id="single-thread-vs-multi-threads">single thread vs multi threads</span></h2><p>适合单线程的场景：单个线程的工作逻辑简单，而且速度非常快，比如从内存中读取某个值，或者从Hash表根据key获得某个value。Redis和Node.js这类程序都是单线程，适合单个线程简单快速的场景。</p><p>适合多线程的场景：单个线程的工作逻辑复杂，等待时间较长或者需要消耗大量系统运算资源，比如需要从多个远程服务获得数据并计算，或者图像处理。</p><h1><span id="synchronized-可重入锁">synchronized (可重入锁）</span></h1><p>每个object创建时都有一个monitor</p><p>Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a “monitor.”) </p><h2><span id="locks-in-synchronized-methods">locks in synchronized methods</span></h2><p>when a thread invokes a synchronized method, it automatically acquires the instrinsic lock for that method’s object and releases it when the method returns</p><h2><span id="重点">重点</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MsLunch &#123;</span><br><span class="line">    private long c1 = 0;</span><br><span class="line">    private long c2 = 0;</span><br><span class="line">    private Object lock1 = new Object();</span><br><span class="line">    private Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">    public void inc1() &#123;</span><br><span class="line">        synchronized(lock1) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inc2() &#123;</span><br><span class="line">        synchronized(lock2) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="reentrant-synchronization">Reentrant Synchronization</span></h2><p>Recall that a thread cannot acquire a lock owned by another thread. But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p><h1><span id="synchronized和lock">synchronized和lock</span></h1><h2><span id="synchronized-的局限性">synchronized 的局限性</span></h2><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性，例如：</p><p>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。<br>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p><h2><span id="lock">Lock</span></h2><p>API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void lock();</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line">boolean tryLock();</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">void unlock();</span><br><span class="line">Condition newCondition();</span><br></pre></td></tr></table></figure><h2><span id="lock使用方式需要手动释放锁">lock使用方式，需要手动释放锁</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock();  可重入锁</span><br><span class="line"> </span><br><span class="line">public void test()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        doSomeThing();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        // ignored</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="aqs">AQS</span></h2><p>AbstractQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。</p><p>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。如图</p><p><img src="aqs.png" alt=""></p><p>AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。</p><p>AbstractQueuedSynchronizer继承了AbstractOwnableSynchronizer，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。</p><p>理解AQS可以帮助我们更好的理解JCU包中的同步容器。</p><h2><span id="lock的类型">lock的类型</span></h2><p>可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。<br>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。<br>公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。<br>CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h1><h2><span id="from-oracle">from oracle</span></h2><p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</p><p>This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don’t want to synchronize traversals, yet need to preclude interference among concurrent threads. </p><h2><span id="from-google-serach">from google serach</span></h2><p>This is a very useful construct in the multi-threaded programs – when we want to iterate over a list in a thread-safe way without an explicit synchronization.</p><p>When we are using any of the modify methods – such as add() or remove() – the whole content of the CopyOnWriteArrayList is copied into the new internal copy.</p><h2><span id="when-to-use-it">when to use it</span></h2><p>dont want to synchronize the traversal operations </p><h2><span id="diff-with-readwritelock">diff with  ReadWriteLock</span></h2><p>CopyOnWriteArrayList is for safe traversals.</p><p>ReadWriteLock would allow multiple readers and still let the occasional writer perform the necessary modifications. </p><h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.ConcurrentModificationException;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class CopyOnWriteArrayListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList = new ArrayList&lt;&gt;();</span><br><span class="line">        empList.add(&quot;yifan&quot;);</span><br><span class="line">        empList.add(&quot;guo&quot;);</span><br><span class="line">        empList.add(&quot;smith&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; empIter = empList.iterator();</span><br><span class="line"></span><br><span class="line">        while(empIter.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(empIter.next());</span><br><span class="line">                if (!empList.contains(&quot;lala&quot;)) empList.add(&quot;lala&quot;);</span><br><span class="line">            &#125; catch (ConcurrentModificationException cme) &#123;</span><br><span class="line">                System.err.println(&quot;attempt to modifiy list during iteration&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList2 = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        empList2.add(&quot;yifan&quot;);</span><br><span class="line">        empList2.add(&quot;guo&quot;);</span><br><span class="line">        empList2.add(&quot;smith&quot;);</span><br><span class="line">        empIter = empList2.iterator();</span><br><span class="line">        while (empIter.hasNext()) &#123;</span><br><span class="line">            System.out.println(empIter.next());</span><br><span class="line">            if (!empList2.contains(&quot;Tom Smith&quot;))</span><br><span class="line">                empList2.add(&quot;Tom Smith&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="transient">transient</span></h1><p>The transient keyword in Java is used to indicate that a field should not be serialized.</p><h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class demo implements Serializable &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private transient String middleName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public demo (String fName, String mName, String lName)&#123;</span><br><span class="line">        this.firstName = fName;</span><br><span class="line">        this.middleName = mName;</span><br><span class="line">        this.lastName = lName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(40);</span><br><span class="line">        sb.append(&quot;First Name : &quot;);</span><br><span class="line">        sb.append(this.firstName);</span><br><span class="line">        sb.append(&quot;Middle Name : &quot;);</span><br><span class="line">        sb.append(this.middleName);</span><br><span class="line">        sb.append(&quot;Last Name : &quot;);</span><br><span class="line">        sb.append(this.lastName);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        demo nameStore = new demo(&quot;Steve&quot;, &quot;Middle&quot;,&quot;Jobs&quot;);</span><br><span class="line">        ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;nameStore&quot;));</span><br><span class="line">        // writing to object</span><br><span class="line">        o.writeObject(nameStore);</span><br><span class="line">        o.close();</span><br><span class="line"></span><br><span class="line">        // reading from object</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;nameStore&quot;));</span><br><span class="line">        demo d = (demo)in.readObject();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="reentrant-lock-可重入锁">Reentrant lock (可重入锁）</span></h1><p>synchronized 也是可重入锁</p><p>2.可中断锁</p><p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>　　3.公平锁</p><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。设置方法如下：ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);</p><h1><span id="readwritelock">ReadWriteLock</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;java-concurrent-package-api&quot;&gt;Java Concurrent Package API&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;cascompare-and-set-nonblockinga
      
    
    </summary>
    
    
      <category term="concurrent" scheme="http://www.yifanguo.top/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Virtual Machine Learning Notes</title>
    <link href="http://www.yifanguo.top/2018/07/26/JVM01/"/>
    <id>http://www.yifanguo.top/2018/07/26/JVM01/</id>
    <published>2018-07-27T01:36:22.000Z</published>
    <updated>2018-07-30T07:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1><span id="the-structure-of-jvm">The Structure of JVM</span></h1><h1><span id="the-class-file-format">the class file format</span></h1><ol><li>Compiled code is in binary format </li><li>stored in a file known as the class file format</li><li>it precisely defines the representation of a class or interface</li><li>it includes details such as byte ordering</li></ol><h1><span id="data-types">data types</span></h1><ol><li>primitive types – primitive values</li><li>reference types – reference values</li><li>all type checking is done prior to run time, by compiler not JVM</li><li>An object is either a dynamically allocated class instance or an array</li><li>A reference to an object is considered to have JVM type reference</li><li>values of type referecence can be thought of as pointers to objects</li></ol><h1><span id="primitive-types-and-values">primitive types and values</span></h1><ol><li>the primitive data types supported by JVM are : numeric types , boolean types, returnAddress type</li><li>numeric types consist of integral types and floating-pointing types</li></ol><h2><span id="numeric-types">numeric types</span></h2><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">size</th><th style="text-align:left">range</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">8-bit</td><td style="text-align:left">-128 to 127</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">16 bit</td><td style="text-align:left">-32768 to 32767</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">32bit</td><td style="text-align:left">-2147483648 to 2147483647</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">64bit</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">16bit</td><td style="text-align:left">0 to 65535 inclusive</td></tr></tbody></table><p>default  char: the null code point (‘\u0000’)</p><h2><span id="floating-pointing-types">floating-pointing types:</span></h2><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">size</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">32 bit</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">64 bit</td></tr></tbody></table><h2><span id="boolean-types-true-or-false">boolean types true or false</span></h2><p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.<br>The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).</p><h2><span id="returnaddress-type">returnAddress type</span></h2><p>The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Of the primitive types, only the returnAddress type is not directly associated with a Java programming language type.</p><p>The returnAddress type is used by the Java Virtual Machine’s jsr, ret, and jsr_w instructions (§jsr, §ret, §jsr_w).</p><p>The values of the returnAddress type are pointers to the opcodes(operation codes) of Java Virtual Machine instructions.</p><h1><span id="reference-types-and-values">Reference types and values</span></h1><p>There are three kinds of reference types:<br>class types,<br>array types,<br>and interface types. </p><p>Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</p><p>The default value of a reference type is null.</p><h1><span id="run-time-data-areas">Run-time data areas</span></h1><p>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p><h2><span id="the-pc-register">the pc register</span></h2><ol><li>The Java Virtual Machine can support many threads of execution at once</li><li>each jvm thread has its own pc(program counter) register</li><li>At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread</li><li>if not native method,  pc contains the address of JVM instruction being executed</li><li>if native method, pc is undefined(null)</li></ol><h2><span id="the-jvm-stack">the JVM stack</span></h2><ol><li>each JVM thread has a private JVM stack</li><li>created as the same time as the thread</li><li>it holds local variables and partial results, and plays a part in method invocation and return</li></ol><p>• If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <strong>StackOverflowError</strong>.</p><p>• If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <strong>OutOfMemoryError</strong>.</p><h2><span id="heap">HEAP</span></h2><ol><li>heap is shared among all jvm threads</li><li>The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li><li>created on virtual machine start-up. </li><li>heap storage for objects is reclaimed by GC</li><li>objects are never explicitly deallocated</li><li>The memory for the heap does not need to be contiguous.</li></ol><p>• If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.</p><h2><span id="method-area">method area</span></h2><ol><li><p>shared among all threads</p></li><li><p>stores per-class structures such as<br><strong>the run-time constant pool</strong><br><strong>field and method data</strong><br><strong>the code for methods and constructors</strong></p></li><li><p>created on jvm start-up</p></li><li>Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.</li></ol><p>• If memory in the method area cannot be made available to satisfy an allocation<br>request, the Java Virtual Machine throws an OutOfMemoryError.</p><h2><span id="run-time-constant-pool">Run-Time Constant Pool</span></h2><ol><li>A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file</li><li>the run-time constant pool for a class or interface is constructed when the class or interface is created (§5.3) by the Java Virtual Machine.</li><li>part of method area</li></ol><h2><span id="native-method-stacks">Native Method Stacks</span></h2><h1><span id="frame">Frame</span></h1><p>A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p><p>A new frame is created each time a method is invoked. </p><p>A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception)</p><p>frames are allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame.</p><p>Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the run- time constant pool (§2.5.5) of the class of the current method.</p><h2><span id="local-variable">local variable</span></h2><p>Each frame (§2.6) contains an array of variables known as its local variables.</p><p>Local variables are addressed by indexing.</p><p>The Java Virtual Machine uses local variables to pass parameters on method invocation. </p><h2><span id="operand-stacks">operand stacks</span></h2><p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. The operand stack is also used to prepare parameters to be passed to methods and to receive method results.</p><h2><span id="dynamic-linking">dynamic linking</span></h2><p>Each frame (§2.6) contains a reference to the run-time constant pool (§2.5.5) for the type of the current method to support dynamic linking of the method code.</p><h1><span id="exceptions">Exceptions</span></h1><p>An exception in the Java Virtual Machine is represented by an instance of the class Throwable or one of its subclasses. </p><p>Throwing an exception results in an immediate nonlocal transfer of control from the point where the exception was thrown.</p><h2><span id="exception-handler">exception handler</span></h2><p>An exception handler specifies the range of offsets into the Java Virtual Machine code implementing the method for which the exception handler is active, describes the type of exception that the exception handler is able to handle, and specifies the location of the code that is to handle that exception</p><p>When an exception is thrown, the Java Virtual Machine searches for a matching exception handler in the current method. If a matching exception handler is found, the system branches to the exception handling code specified by the matched handler.</p><h2><span id="instruction-set-summary">instruction set summary</span></h2><p>A Java Virtual Machine instruction consists of a one-byte opcode specifying the operation to be performed, followed by zero or more operands supplying arguments or data that are used by the operation.</p><p> i for an int operation, l for long, s for short, b for byte, c for char, f for float, d for double, and a for reference.</p><p> Given the Java Virtual Machine’s one-byte opcode size, encoding types into opcodes places pressure on the design of its instruction set. </p><p> The only integer operations that can throw an exception are the integer divide instructions (idiv and ldiv) and the integer remainder instructions (irem and lrem), which throw an ArithmeticException if the divisor is zero.</p><h1><span id="object-creation-and-manipulation">Object Creation and Manipulation</span></h1><ol><li>both class instances and arrays are objects,</li><li>creates and manipulates class instances and arrays using distinct sets of instructions:</li><li>Create a new class instance: new.</li><li>Access fields of classes (static fields, known as class variables) and fields of class instances (non-static fields, known as instance variables): getstatic, putstatic, getfield, putfield.</li><li>Check properties of class instances or arrays: instanceof, checkcast.</li></ol><h1><span id="synchironization">Synchironization</span></h1><p>synchronization construct: the monitor.</p><p>When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. </p><p>During the time the executing thread owns the monitor, no other thread may enter it.</p><p>Synchronization of sequences of instructions is typically used to encode the synchronized block of the Java programming language.</p><p>The Java Virtual Machine supplies the monitorenter and monitorexit instructions to support such language constructs. </p><p>Note that the monitor entry and exit automatically performed by the Java Virtual Machine when invoking a synchronized method are considered to occur during the calling method’s invocation.</p><h1><span id="compiling">Compiling</span></h1><p>Compiler transfer java code into instruction set of the jvm</p><p>Just-in-time code generator(JIT)<br>Note that the term “compiler” is sometimes used when referring to a translator from the instruction set of a Java Virtual Machine to the instruction set of a specific CPU. </p><h1><span id="synchironization">Synchironization</span></h1><p>Synchronization in the Java Virtual Machine is implemented by monitor entry and exit</p><h1><span id="the-class-file-format">the class file format</span></h1><p><img src="theClassFile.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;the-structure-of-jvm&quot;&gt;The Structure of JVM&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;the-class-file-format&quot;&gt;the class file format&lt;
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.yifanguo.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>cglib</title>
    <link href="http://www.yifanguo.top/2018/07/25/cglib/"/>
    <id>http://www.yifanguo.top/2018/07/25/cglib/</id>
    <published>2018-07-26T06:08:40.000Z</published>
    <updated>2018-07-26T06:54:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cglib-code-generation-library">cglib – code generation library</span></h1><p>it is a byte instrumentation library used in many java framework such as hibernate or spring</p><p>the bytecode instrumentation allows manipulating or creating classes after the compilation phase of a program</p><h1><span id="function">function</span></h1><p>Classes in Java are loaded dynamically at runtime. Cglib is using this feature of Java language to make it possible to add new classes to an already running Java program.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;cglib-code-generation-library&quot;&gt;cglib – code generation library&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;it is a byte instrumentation library used in many
      
    
    </summary>
    
    
      <category term="cglib" scheme="http://www.yifanguo.top/tags/cglib/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper.md</title>
    <link href="http://www.yifanguo.top/2018/07/25/zookeeper-md/"/>
    <id>http://www.yifanguo.top/2018/07/25/zookeeper-md/</id>
    <published>2018-07-26T04:41:20.000Z</published>
    <updated>2018-07-26T06:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="overview">Overview</span></h1><p>ZooKeeper is a distributed, open-source coordination service for distributed applications.</p><h1><span id="purpose">Purpose</span></h1><p>Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;overview&quot;&gt;Overview&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;ZooKeeper is a distributed, open-source coordination service for distributed applications.&lt;/p
      
    
    </summary>
    
    
      <category term="zookeeper" scheme="http://www.yifanguo.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>netty源码解读</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty源码解读/</id>
    <published>2018-07-26T01:33:49.000Z</published>
    <updated>2018-07-26T01:33:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty学习笔记Chapter08</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Chapter08/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记Chapter08/</id>
    <published>2018-07-25T15:23:24.000Z</published>
    <updated>2018-07-25T15:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="chapter8">Chapter8</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;chapter8&quot;&gt;Chapter8&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记Chapter6</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Chapter6/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记Chapter6/</id>
    <published>2018-07-25T11:36:24.000Z</published>
    <updated>2018-07-25T15:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="chapter-6">chapter 6</span></h1><p>java序列化的目的主要有两个：</p><ol><li>网络传输</li><li>对象持久化</li></ol><p>java序列化从jdk1.1就已经提供，只需要implements java.io.Serializable并生成序列id就可以<br>但是rpc很少使用java序列化来进行消息的encoding 和decoding</p><p>原因</p><ol><li>无法跨语言</li><li>序列化后码流太大</li></ol><p>评判编解码框架优劣<br>1 是否支持跨语言<br>2 编码后的码流大小<br>3 编解码的性能<br>4 类库是否小巧，API使用是否方便<br>5 使用者需要手工快发的工作量和难度</p><h1><span id="业界主流的编解码框架">业界主流的编解码框架</span></h1><h2><span id="google的protobuf">Google的protobuf</span></h2><p>它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的pojo对象和protobuf相关的方法和属性</p><ol><li>结构化数据存储格式 xml json</li><li>高效的encoding decoding性能</li><li>语言无关，平台无关，扩展性好</li><li>支持java c++ python</li></ol><h2><span id="facebook的thrift">Facebook的Thrift</span></h2><ol><li>语言系统以及IDL编译器，负责由用户给定的IDL文件生成相应语言的接口代码</li><li>Tprotocol: rpc协议层，可以选择多种不同的对象序列化方式 如json 和binary</li><li>TTransport： RPC传输层，可以选择不同的传输层实现 如socket, NIO. memoryBuffer</li><li>TProcessor: 做为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口</li><li>TServer: 聚合TProtocol, TTransport, TProcessor等对象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;chapter-6&quot;&gt;chapter 6&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;java序列化的目的主要有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络传输&lt;/li&gt;
&lt;li&gt;对象持久化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java序列化从jdk1.1就已经提供，只需要impl
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter5</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter5/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter5/</id>
    <published>2018-07-25T10:30:47.000Z</published>
    <updated>2018-07-25T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty-chapter5">netty chapter5</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty-chapter5&quot;&gt;netty chapter5&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter4</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter4/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter4/</id>
    <published>2018-07-25T09:55:32.000Z</published>
    <updated>2018-07-25T10:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty-chapter4">netty chapter4</span></h1><p>TCP底层并不了解上层业务数据的具体含义<br>它会根据tcp缓冲区的实际情况进行包的划分<br>所以一个完整的包可能会被tcp拆分成多个包进行发送<br>也有可能把多个小的包封装成一个大的数据包发送<br>这就是tcp 粘包和拆包的问题</p><h1><span id="问题产生的原因">问题产生的原因</span></h1><ol><li>application write写入的字节大小大于socket发送缓冲区的大小</li><li>进行mss大小的tcp分段</li><li>以太网帧的payload大于mtu进行ip分片</li></ol><p><img src="/Users/yifanguo/Desktop/屏幕快照 2018-07-25 03.23.27.png" alt=""></p><p>这个问题只能通过上层的应用协议stack来解决</p><ol><li>消息定长，每个msg大小为固定的200byte,如果不够，空位补空格</li><li>在包尾增加回车换行符进行分割 FTP协议</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32表示消息的总长度</li><li>更复杂的应用层协议</li></ol><h1><span id="netty如何解决">netty如何解决</span></h1><p>LinebasedFrameDecoder + Stringdecoder 文本格式的解码器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty-chapter4&quot;&gt;netty chapter4&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;TCP底层并不了解上层业务数据的具体含义&lt;br&gt;它会根据tcp缓冲区的实际情况进行包的划分&lt;br&gt;所以一个完整的包可能会被tcp拆分成多个包进行发送&lt;br&gt;也有可
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter3</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter3/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter3/</id>
    <published>2018-07-25T09:40:57.000Z</published>
    <updated>2018-07-25T09:41:07.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty学习笔记chapter2</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter2/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter2/</id>
    <published>2018-07-25T08:44:41.000Z</published>
    <updated>2018-07-25T09:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty-chapter2">netty chapter2</span></h1><h2><span id="传统的bio编程">传统的BIO编程</span></h2><p>网络编程的基本模式是c/s client/server。<br>实际处理的就是两个进程之间的通信问题</p><p>其中server提供位置信息 ipaddress+port<br>客户端通过connect向server的port send request<br>通过三次握手建立连接 如果连接成功，双方就可以通过socket 进行通信</p><p>在基于传统同步阻塞模型开发中，server socket负责绑定ip地址，启动监听端口<br>sokcet负责发起连接操作。<br>连接成功之后，双方通过输入和输出流进行同步阻塞式通信</p><h2><span id="buffer-缓冲区">Buffer 缓冲区</span></h2><p>buffer是一个object 它包含一些要写入或者要读出的data</p><p>NIO中所有data都是通过buffer处理</p><p>buffer实质上是一个数组，通常是一个字节数组bytebuffer</p><p>bytebuffer, charbuffer, doublebuffer, floatbuffer, intbuffer, longbuffer, shortbuffer<br>mappedbytebuffer<br>每一个都是buffer接口的instance 操作完全一样</p><h2><span id="channel">channel</span></h2><p>channel是一个通道，它就像自来水管一样，网络数据通过channel读取和写入</p><p>channel和stream不同之处在于 通道是双向的，流只是在一个方向上移动<br>（如inputstream outputstream都是stream的instance 单方向）</p><h2><span id="selector">selector</span></h2><p>selector会不断轮询注册在其上的channel,如果某个channel上面发生读或者写事件，这个channel就处于就绪状态，<br>会被selector轮询出来，然后通过selectionKey可以获取就绪channel的集合，进行后续的i/o操作</p><p>只需要一个线程负责selector（使用epoll)的轮询就可以接入成千上万的客户端</p><p><img src="/Users/yifanguo/Desktop/屏幕快照 2018-07-25 02.17.19.png" alt=""></p><p>NIO server通信时序图</p><ol><li>打开serverSokcetChannel,用于监听客户端的connection,它是所有client connection的父管道</li><li>绑定监听端口，设置connection为非阻塞模式</li><li>创建reactor线程，创建selector并启动线程</li><li>将serverSocketChannel注册到reactor线程的selector上，监听accept事件</li><li>selector在thread run的无限循环体内轮询准备就绪的key</li><li>selector监听到有新的客户端接入，处理新的接入请求，完成tcp三次握手，建立物理链路</li><li>设置客户端链路为非阻塞模式</li><li>将新接入的客户端注册到reactor线程的selector上，监听读操作，读取客户端发送的网络消息</li><li>异步读取客户端请求消息到buffer</li><li>对buffer进行编解码。如果有半包消息指针reset,继续读取后续的msg,将解码成功的消息封装成task,投递到业务threadpool中，进行业务逻辑编排</li><li>将pojo对象encode成bytebuffer,调用socketchannel的异步write接口，将消息异步发送给客户端</li><li>如果发送区tcp缓冲区满，会导致写半包，此时，需要注册监听写操作位，循环写，直到整包消息写入tcp缓冲区。</li></ol><h2><span id="为什么选择netty而不是自己开发nio">为什么选择netty而不是自己开发NIO</span></h2><ol><li>开发出高质量的NIO程序不简单</li><li>NIO服务器需要能够handle 网络的闪断，客户端重复接入，客户端安全认证，消息的编解码，半包读写等情况</li><li>跟踪和检测困难</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;netty-chapter2&quot;&gt;netty chapter2&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;传统的bio编程&quot;&gt;传统的BIO编程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;网络编程的基本模式是c/s client/server。&lt;br&gt;实际处理的
      
    
    </summary>
    
    
      <category term="netty" scheme="http://www.yifanguo.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty权威只能学习笔记chapter1</title>
    <link href="http://www.yifanguo.top/2018/07/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0chapter1/"/>
    <id>http://www.yifanguo.top/2018/07/25/netty学习笔记chapter1/</id>
    <published>2018-07-25T08:19:09.000Z</published>
    <updated>2018-07-25T08:44:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="chapter-01-java-io">chapter 01 –java i/o</span></h1><h2><span id="io-多路复用技术">i/o 多路复用技术</span></h2><p>i/o多路复用技术通过把多个i/o的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</p><p>和传统的多线程相比：<br>1: i/o多路复用的最大优势是系统开销小，不需要创建新的额外的线程或进程<br>2：服务器需要同时处理多个处于监听状态或者多个连接状态的套接字<br>3: 服务器需要同时处理多种网络协议套接字</p><h2><span id="epoll-vs-select">epoll vs select</span></h2><p>select最大的缺陷就是单个进程所打开的FD有一定限制，它由FD_SETSIZE设置，默认值是1024.<br>对于那些需要支持上万个tcp connection的服务器来说太少了</p><p>我们可以选择多进程的方案（传统的apache方案）来解决这个问题。</p><p>但是进程间交换数据非常麻烦，对于java来说，由于没有共享内存，需要通过socket通信或者其他方式进行数据同步。</p><p>epoll没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远远大于1024</p><p>cat /proc/sys/fs/file -max查看，这个值和系统内存关系比较大</p><h2><span id="io效率不会随着fd数目的增加而线性下降">i/o效率不会随着fd数目的增加而线性下降</span></h2><p>传统的select/poll的另一个致命弱点： socket集合很大，由于网络延时或者链路空闲，任一时刻只有少部分的socket是活跃的。</p><p>但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。</p><p>epoll不存在这个问题，它只会对活跃的socket进行操作</p><p>epoll是根据每个fd上面的callback函数实现的，只有活跃的socket才主动调用callback函数，其他idle状态的socket则不会</p><h2><span id="使用mmap加速内核与用户空间的消息传递">使用mmap加速内核与用户空间的消息传递</span></h2><ol><li>select, poll 还是epoll都需要内核把FD消息通知给用户空间</li><li>epoll 是通过内核和用户空间mmap同一个内存来实现，避免不必要的内存复制</li></ol><h1><span id="jdk14-nio以jsr-51的身份正式发布">JDK1.4 NIO以JSR-51的身份正式发布</span></h1><ol><li>进行异步i/o操作的缓冲区bytebuffer</li><li>————–管道pipe</li><li>channel serverSocketChannel 和 soketchannel</li><li>多种字符集的编码能力和解码能力</li><li>非阻塞i/o操作的多路复用器selector</li><li>基于perl实现的正则表达式类库</li><li>文件通道fileChannel</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;chapter-01-java-io&quot;&gt;chapter 01 –java i/o&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;io-多路复用技术&quot;&gt;i/o 多路复用技术&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;i/o多路复用技术通过把多个i/o的阻塞复用到同
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java_concurrent_volatile02</title>
    <link href="http://www.yifanguo.top/2018/07/25/java-concurrent-volatile02/"/>
    <id>http://www.yifanguo.top/2018/07/25/java-concurrent-volatile02/</id>
    <published>2018-07-25T07:04:18.000Z</published>
    <updated>2018-07-25T07:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="volatile">volatile</span></h1><ol><li>保证内存可见性。</li><li>保证排序，不会因为指令重排导致问题</li><li>不保证原子性</li></ol><h1><span id="demo">Demo</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static int flag = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new ThreadA().start();</span><br><span class="line">        new ThreadB().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 线程A进入死循环直到读出变量大于3</span><br><span class="line">    // 会发现线程A永远无法跳出循环，因为flag不是volatile类型变量</span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (flag &gt;= 3) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;in CustomerInLine....&quot; + flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 线程B不停增加flag值，但是jvm会把flag写进cpu cache提升优化</span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (flag &lt; 10) &#123;</span><br><span class="line">                System.out.println(&quot;in Queue ...&quot; + flag++);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(200);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决的办法很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static int flag = 0;</span><br></pre></td></tr></table></figure><h1><span id="指令重排">指令重排</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MainOrder &#123;</span><br><span class="line"></span><br><span class="line">    private static String context = null;</span><br><span class="line">    private static boolean flag;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new MainOrder.ThreadA().start();</span><br><span class="line">        new MainOrder.ThreadB().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           context = &quot;hello word&quot;;</span><br><span class="line">           flag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (!flag) &#123;</span><br><span class="line">                    sleep(100);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(context);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指令重排，threadB会先看到true然后print一个null</p><h1><span id="不保证原子性">不保证原子性</span></h1><p>如果多个线程同时读写一个volatile变量，不保证原子性。<br>使用java concurrent包来解决这个问题，或者加入synchronized声明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;volatile&quot;&gt;volatile&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;保证内存可见性。&lt;/li&gt;
&lt;li&gt;保证排序，不会因为指令重排导致问题&lt;/li&gt;
&lt;li&gt;不保证原子性&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;span id=&quot;demo&quot;&gt;Demo
      
    
    </summary>
    
    
      <category term="concurrent" scheme="http://www.yifanguo.top/tags/concurrent/"/>
    
  </entry>
  
</feed>
