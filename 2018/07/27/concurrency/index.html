<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="concurrency," />





  <link rel="alternate" href="/atom.xml" title="Yifan Guo Personal Blog" type="application/atom+xml" />






<meta name="description" content="[toc] Java Concurrent Package APISynchronized12345678public class Test &amp;#123;    public void test() &amp;#123;        synchronized (this) &amp;#123;            //do nothing        &amp;#125;    &amp;#125;&amp;#125; 12345">
<meta name="keywords" content="concurrency">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Concurrent Package API">
<meta property="og:url" content="http://www.yifanguo.top/2018/07/27/concurrency/index.html">
<meta property="og:site_name" content="Yifan Guo Personal Blog">
<meta property="og:description" content="[toc] Java Concurrent Package APISynchronized12345678public class Test &amp;#123;    public void test() &amp;#123;        synchronized (this) &amp;#123;            //do nothing        &amp;#125;    &amp;#125;&amp;#125; 12345">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.yifanguo.top/2018/07/27/concurrency/juc.png">
<meta property="og:image" content="http://www.yifanguo.top/2018/07/27/concurrency/countDownLatch">
<meta property="og:image" content="http://www.yifanguo.top/2018/07/27/concurrency/aqs.png">
<meta property="og:updated_time" content="2018-08-01T03:58:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Concurrent Package API">
<meta name="twitter:description" content="[toc] Java Concurrent Package APISynchronized12345678public class Test &amp;#123;    public void test() &amp;#123;        synchronized (this) &amp;#123;            //do nothing        &amp;#125;    &amp;#125;&amp;#125; 12345">
<meta name="twitter:image" content="http://www.yifanguo.top/2018/07/27/concurrency/juc.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yifanguo.top/2018/07/27/concurrency/"/>





  <title>Java Concurrent Package API | Yifan Guo Personal Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/esail" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yifan Guo Personal Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-http">
          <a href="/http/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            http
          </a>
        </li>
      
        
        <li class="menu-item menu-item-netty">
          <a href="/netty/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            netty
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yifanguo.top/2018/07/27/concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yifan Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yifan Guo Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Concurrent Package API</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-27T02:47:40-07:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[toc]</p>
<h1><span id="java-concurrent-package-api">Java Concurrent Package API</span></h1><h1><span id="synchronized">Synchronized</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public top.yifan.synchronizedDemos.Test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public void test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter</span><br><span class="line">       4: aload_1</span><br><span class="line">       5: monitorexit</span><br><span class="line">       6: goto          14</span><br><span class="line">       9: astore_2</span><br><span class="line">      10: aload_1</span><br><span class="line">      11: monitorexit</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: athrow</span><br><span class="line">      14: return</span><br><span class="line">    Exception table:</span><br></pre></td></tr></table></figure>
<p>可以看到synchronized 由monitorenter和monitorexit 控制， 这确保只有一个线程可以访问critical section</p>
<h1><span id="juc结构">JUC结构</span></h1><p><img src="juc.png" alt=""></p>
<h1><span id="aqs-abstractqueuedsynchronizer">AQS (abstractQueuedSynchronizer)</span></h1><p>这是一个framework,被N多java concurrent API 调用<br>先看官方解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Provides a framework for implementing blocking locks and related</span><br><span class="line">* synchronizers (semaphores, events, etc) that rely on</span><br><span class="line">* first-in-first-out (FIFO) wait queues.</span><br></pre></td></tr></table></figure>
<p>给同步器提供一个fifo的队列</p>
<p>This class is designed to<br>be a useful basis for most kinds of synchronizers that rely on a<br>single atomic {@code int} value to represent state.</p>
<p>同步器依赖单个的原子变量，如countDownLatch</p>
<h1><span id="latch-闭锁">Latch (闭锁）</span></h1><ol>
<li>确保所有资源都初始化后再执行thread</li>
<li>确保某个服务在其依赖的服务都启动后再执行</li>
<li>等待某个操作的所有参与者都准备就绪后再执行</li>
</ol>
<p>latch就是阀门的意思，门没打开前，所有线程都将等待</p>
<h1><span id="countdownlatch">CountDownLatch</span></h1><p><img src="countDownLatch" alt=""></p>
<p>使一个或多个线程等待一组事件发生<br>包括一个计数器，初始化是一个正数表示需要等待的event数量</p>
<p>countDown递减计数器，await方法等待计数器达到0</p>
<p>来看源代码<br>A synchronization aid that allows one or more threads to wait until<br>a set of operations being performed in other threads completes.</p>
<p>This is a one-shot phenomenon<br>– the count cannot be reset.  If you need a version that resets the<br>count, consider using a {@link CyclicBarrier}.</p>
<p>CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p>
<p>虽然，CountDownlatch与CyclicBarrier有那么点相似，但是他们还是存在一些区别的：</p>
<p>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待</p>
<p>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier</p>
<p>自旋尝试获取state</p>
<h2><span id="await">await</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 对于CountDownLatch而言，如果计数器值不等于0，那么r 会一直小于0</span><br><span class="line">                     */</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //等待</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="countdown">countDown()</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取锁状态</span><br><span class="line">            int c = getState();</span><br><span class="line">            //c == 0 直接返回，释放锁成功</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            //计算新“锁计数器”</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            //更新锁状态（计数器）</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1><span id="unsafe-instances">Unsafe instances</span></h1><h2><span id="锁不一致">锁不一致</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ListHelper&lt;E&gt; &#123;</span><br><span class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">    //list 上的锁 不是listHelper上的锁，所以putIfAbsent相对于list其它的操作并不是thread-safe</span><br><span class="line">    </span><br><span class="line">    public synchronized boolean putIfAbsent(E x) &#123;</span><br><span class="line">        boolean absent = !list.contains(x);</span><br><span class="line">        if (absent) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ListHelper&lt;E&gt; &#123;</span><br><span class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">    //list 上的锁 不是listHelper上的锁，所以putIfAbsent相对于list其它的操作并不是thread-safe</span><br><span class="line">    </span><br><span class="line">    public boolean putIfAbsent(E x) &#123;</span><br><span class="line">    	  synchronized(list) &#123;</span><br><span class="line">	        boolean absent = !list.contains(x);</span><br><span class="line">	        if (absent) &#123;</span><br><span class="line">	            list.add(x);</span><br><span class="line">	        &#125;</span><br><span class="line">	        return absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的做法是学习synchronizedCollections 对每一个方法都加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 3053995032091335093L;</span><br><span class="line"></span><br><span class="line">        final Collection&lt;E&gt; c;  // Backing Collection</span><br><span class="line">        final Object mutex;     // Object on which to synchronize</span><br><span class="line"></span><br><span class="line">        SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">            this.c = Objects.requireNonNull(c);</span><br><span class="line">            mutex = this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123;</span><br><span class="line">            this.c = Objects.requireNonNull(c);</span><br><span class="line">            this.mutex = Objects.requireNonNull(mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.contains(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public Object[] toArray() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toArray();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toArray(a);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return c.iterator(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean containsAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.containsAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.addAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean removeAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.removeAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean retainAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.retainAll(coll);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            synchronized (mutex) &#123;c.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.toString();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Override default methods in Collection</span><br><span class="line">        @Override</span><br><span class="line">        public void forEach(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">            synchronized (mutex) &#123;c.forEach(consumer);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">            synchronized (mutex) &#123;return c.removeIf(filter);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return c.spliterator(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Stream&lt;E&gt; stream() &#123;</span><br><span class="line">            return c.stream(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">            return c.parallelStream(); // Must be manually synched by user!</span><br><span class="line">        &#125;</span><br><span class="line">        private void writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">            synchronized (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1><span id="concurrentmap">ConcurrentMap</span></h1><p>采用了分段锁，一种更细粒度的加锁机制 （locking striping)</p>
<p>Concurrent带来更高的吞吐量，单线程情况下只牺牲了很小的性能</p>
<p>ConcurrentMap的iterator不会抛出ConcurrentModificationException</p>
<p>只有程序需要独占map时才放弃concurrentMap</p>
<p>详情请阅读另一篇java collections详解</p>
<h1><span id="concurrentmodificationexception">ConcurrentModificationException</span></h1><p>如果容器在迭代的过程中被其他线程修改了，会抛出这个异常</p>
<p>可以克隆容器，将迭代在副本上进行<br>克隆过程仍然需要加锁</p>
<p>参考copyonwriteCollections系列</p>
<h1><span id="operating-system">Operating System</span></h1><ol>
<li>为各个独立执行的进程分配各种资源包括内存，文件句柄，安全证书等</li>
<li>不同进程之间可以进行粗粒度的通信，socket, signal processor, shared memory, 信号量和文件</li>
</ol>
<h1><span id="thread">Thread</span></h1><p><a href="https://blog.csdn.net/u012398362/article/details/51475213" target="_blank" rel="noopener">https://blog.csdn.net/u012398362/article/details/51475213</a></p>
<ol>
<li>线程会共享进程范围内的资源，内存句柄，文件句柄</li>
<li>线程有各自的程序计数器，stack和局部变量（一组寄存器 存local variables)</li>
<li>同一个程序的多个thread可以被同时调度到多个cpu上运行</li>
<li>线程也被称为轻量级进程 是最基本的调度单元</li>
<li>进程是系统分配资源的基本单位，线程时调度CPU的基本单位</li>
<li>线程间的切换代价要比进程切换的代价小</li>
</ol>
<h1><span id="thread-security">thread security</span></h1><ol>
<li>对共享的 shared 和mutable可变的 状态进行管理</li>
</ol>
<h1><span id="三种同步方式">三种同步方式</span></h1><ol>
<li>不在线程之间共享该状态 threadlocal</li>
<li>将状态变量改为不可变 final</li>
<li>访问时 使用同步机制 synchronized </li>
</ol>
<h1><span id="nio">NIO</span></h1><p>non-blocking i/o复杂性远远大于 i/o<br>即使客户端很多，在很多平台线程创建上限也很高，完全可以让每个客户端都拥有一个自己的线程</p>
<p>所以netty并不一定适合所有的系统</p>
<h1><span id="context-switch-上下文切换">Context Switch （上下文切换）</span></h1><p>当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销<br>保存和恢复上下文使cpu花更多的时间在线程调度上。</p>
<h1><span id="同步机制">同步机制</span></h1><p>当线程共享数据时，必须使用同步机制，这些机制会抑制某些编译器的油画，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量</p>
<p><strong>一个线程只能在一个cpu socket上运行？？</strong> 这句是对的 出自《java并发实战》<br><strong>jvm能不能够将单个线程安排到不同的cpu上去运行呢？</strong> 不可以 jvm可以把多个线程安排到多个cpu上</p>
<p>在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制</p>
<h1><span id="intrinsic-lock">intrinsic lock</span></h1><p>每一个java object都可以用作一个实现同步的锁 这种锁称为内置锁或者monitor lock</p>
<p>sychronized (lock) {</p>
<p>}</p>
<h1><span id="private-lock">private lock</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PrivateLock &#123;</span><br><span class="line">    private final Object myLock = new Object();</span><br><span class="line">    Object widget;</span><br><span class="line">    </span><br><span class="line">    void someMethod() &#123;</span><br><span class="line">        synchronized (myLock) &#123;</span><br><span class="line">            // visit widget</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java synchronizedCollection也使用了 monitor pattern<br>优点 封装了锁，客户代码无法通过共有方法获取到lock</p>
<h1><span id="volatile">volatile</span></h1><ol>
<li>volatile声明的变量不会被缓存到寄存器中，简而言之，就是volatitle变量的load一定会去main memory中查询</li>
<li>volatile禁止了重排序</li>
<li>不保证同步</li>
<li>只能保证可见性，lock还可以保证原子性</li>
</ol>
<h1><span id="publish-and-escape">publish and escape</span></h1><p>有点看不懂…</p>
<h1><span id="线程封闭-threadlocal">线程封闭 threadlocal</span></h1><p>ThreadLocal<t> 可以被视为 Map&lt;Thread, T&gt;  </t></p>
<h1><span id="final-and-private">final and Private</span></h1><p>除非需要某个field是mutable的 否则都声明为final<br>除非需要更高的可见性，否则应将所有field都声明为private</p>
<h1><span id="cas-compareandswapint">CAS-compareAndSwapInt</span></h1><p>Unsafe中有一个method compareAndSwapInt 实现的是无锁同步的机制<br>我们看下它是如何实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">         * Compares the value of the integer field at the specified offset</span><br><span class="line">         * in the supplied object with the given expected value, and updates</span><br><span class="line">         * it if they match.  The operation of this method should be atomic,</span><br><span class="line">         * thus providing an uninterruptible way of updating an integer field.</span><br><span class="line">         * 在obj的offset位置比较integer field和期望的值，如果相同则更新。这个方法</span><br><span class="line">         * 的操作应该是原子的，因此提供了一种不可中断的方式更新integer field。</span><br><span class="line">         *</span><br><span class="line">         * @param obj the object containing the field to modify.</span><br><span class="line">         *            包含要修改field的对象</span><br><span class="line">         * @param offset the offset of the integer field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line">         *               &lt;code&gt;obj&lt;/code&gt;中整型field的偏移量</span><br><span class="line">         * @param expect the expected value of the field.</span><br><span class="line">         *               希望field中存在的值</span><br><span class="line">         * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line">         *           如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line">         * @return true if the field was changed.</span><br><span class="line">         *                             如果field的值被更改</span><br><span class="line">         */</span><br><span class="line">         </span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>
<p>调用了JNI，也就是说有对应的unsafe.cpp的接口 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  //获取对象的变量的地址</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  //调用Atomic操作</span><br><span class="line">  //进入atomic.hpp,大意就是先去获取一次结果，如果结果和现在不同，就直接返回，因为有其他人修改了；否则会一直尝试去修改。直到成功。</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>再来看atomic::cmpxchg这个方法实现，这是一个c++的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123;</span><br><span class="line">  assert(sizeof(jbyte) == 1, &quot;assumption.&quot;);</span><br><span class="line">  uintptr_t dest_addr = (uintptr_t)dest;</span><br><span class="line">  uintptr_t offset = dest_addr % sizeof(jint);</span><br><span class="line">  volatile jint* dest_int = (volatile jint*)(dest_addr - offset);</span><br><span class="line">  jint cur = *dest_int;</span><br><span class="line">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class="line">  jint new_val = cur;</span><br><span class="line">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class="line">  new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  while (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line">    if (res == cur) break;</span><br><span class="line">    cur = res;</span><br><span class="line">    new_val = cur;</span><br><span class="line">    new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  &#125;</span><br><span class="line">  return cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jint* dest_int 做了volatile，意味着值不会从cpu cache中获取，会从主内存中获取</p>
<p>CAS是Compare And Set的缩写。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>1.原语由若干条指令组成的，用于完成一定功能的一个过程。</p>
<p>2、即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
<p>在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀’LOCK’，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p>
<h1><span id="memory-barrier">memory barrier</span></h1><p>内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>
<p>内存屏障（memory barrier）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
<h1><span id="bus-locking">Bus locking</span></h1><h2><span id="from-intel-manual-volume-3">from Intel Manual, Volume 3</span></h2><p>Intel 64 and IA-32 processors provide a LOCK# signal that is asserted automatically during certain critical memory operations to lock the system bus or equivalent link. While this output signal is asserted, requests from other processors or bus agents for control of the bus are blocked. Software can specify other occasions when the LOCK semantics are to be followed by prepending the LOCK prefix to an instruction.</p>
<h1><span id="unsafe">Unsafe</span></h1><p>Unsafe API大部分方法都是native实现（不是java实现的），<br>unsafe是cpp 实现，本质上是cpp的new和delete</p>
<p>Synchronization：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** @deprecated */</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">/** @deprecated */</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public native void putOrderedInt(Object var1, long var2, int var4);</span><br></pre></td></tr></table></figure>
<p>Memory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native long allocateMemory(long var1);</span><br><span class="line">public native long reallocateMemory(long var1, long var3);</span><br><span class="line">public native void setMemory(Object var1, long var2, long var4, byte var6);</span><br><span class="line">public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);</span><br></pre></td></tr></table></figure>
<h1><span id="native">native</span></h1><p>The native keyword is applied to a method to indicate that the method is implemented in native code using JNI (Java Native Interface).</p>
<p>It marks a method, that it will be implemented in other languages, not in Java. It works together with JNI (Java Native Interface).</p>
<h1><span id="cas">CAS</span></h1><p>(compare and set) – nonblockingAlgorithm</p>
<p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p>
<p>总线加锁：总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p>
<p>缓存加锁：其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<h2><span id="cas缺陷">CAS缺陷</span></h2><p>循环时间太长</p>
<p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p>
<p>只能保证一个共享变量原子操作</p>
<p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p>
<p><strong>ABA问题</strong></p>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p>
<p>CAS的ABA隐患问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。对于上面的案例应该线程1会失败。</p>
<p>以下例子充分说明了ABA问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    private static AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        atomicInteger = new AtomicInteger(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //AtomicInteger</span><br><span class="line">        Thread at1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                atomicInteger.compareAndSet(100,110);</span><br><span class="line">                atomicInteger.compareAndSet(110,100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread at2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      // at1,执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        at1.start();</span><br><span class="line">        at2.start();</span><br><span class="line"></span><br><span class="line">        at1.join();</span><br><span class="line">        at2.join();</span><br><span class="line"></span><br><span class="line">        //AtomicStampedReference</span><br><span class="line"></span><br><span class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //让 tsf2先获取stamp，导致预期时间戳不一致</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1</span><br><span class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int stamp = atomicStampedReference.getStamp();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tsf1.start();</span><br><span class="line">        tsf2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下面的这个程序，多线程计数器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp</span><br><span class="line">&#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    public synchronized void upateVisitors() </span><br><span class="line">    &#123;</span><br><span class="line">       ++count; //increment the visitors count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证了可见性，原子性，但是牺牲了delay和overhead.这个牺牲非常大，详情见 Is multi-threading really worth it?</p>
<p>为了解决这个问题，原子结构被introduced</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp</span><br><span class="line">&#123;</span><br><span class="line">    private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">    public void upateVisitors() </span><br><span class="line">    &#123;</span><br><span class="line">       count.incrementAndGet(); //increment the visitors count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS does not make use of locking rather it is very optimistic in nature.<br>It follows these steps:</p>
<ol>
<li><p>Compare the value of the primitive to the value we have got in hand.</p>
</li>
<li><p>If the values do not match it means some thread in between has changed the value. Else it will go ahead and swap the value with new value.</p>
</li>
</ol>
<h2><span id="is-multi-threading-really-worth-it">Is multi-threading really worth it?</span></h2><p>多线程的目的是最大限度的利用cpu资源</p>
<p>超线程技术本质上是把进程的线程 映射到不同的cpu core上</p>
<h2><span id="context-switch">context switch</span></h2><p>作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，为了让用户感觉这些任务正在同时进行，操作系统的设计者巧妙地利用了时间片轮转的方式，CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载，这段过程就叫做上下文切换</p>
<h2><span id="single-thread-vs-multi-threads">single thread vs multi threads</span></h2><p>适合单线程的场景：单个线程的工作逻辑简单，而且速度非常快，比如从内存中读取某个值，或者从Hash表根据key获得某个value。Redis和Node.js这类程序都是单线程，适合单个线程简单快速的场景。</p>
<p>适合多线程的场景：单个线程的工作逻辑复杂，等待时间较长或者需要消耗大量系统运算资源，比如需要从多个远程服务获得数据并计算，或者图像处理.</p>
<h1><span id="synchronized-可重入锁">synchronized (可重入锁）</span></h1><p>每个object创建时都有一个monitor</p>
<p>Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a “monitor.”) </p>
<p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h2><span id="locks-in-synchronized-methods">locks in synchronized methods</span></h2><p>when a thread invokes a synchronized method, it automatically acquires the instrinsic lock for that method’s object and releases it when the method returns</p>
<h2><span id="重点">重点</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MsLunch &#123;</span><br><span class="line">    private long c1 = 0;</span><br><span class="line">    private long c2 = 0;</span><br><span class="line">    private Object lock1 = new Object();</span><br><span class="line">    private Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">    public void inc1() &#123;</span><br><span class="line">        synchronized(lock1) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inc2() &#123;</span><br><span class="line">        synchronized(lock2) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="reentrant-synchronization">Reentrant Synchronization</span></h2><p>Recall that a thread cannot acquire a lock owned by another thread. But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p>
<h1><span id="synchronized和lock">synchronized和lock</span></h1><h2><span id="synchronized-的局限性">synchronized 的局限性</span></h2><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性，例如：</p>
<p>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。<br>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p>
<h2><span id="lock">Lock</span></h2><p>API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void lock();</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line">boolean tryLock();</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">void unlock();</span><br><span class="line">Condition newCondition();</span><br></pre></td></tr></table></figure>
<h2><span id="lock使用方式需要手动释放锁">lock使用方式，需要手动释放锁</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock();  可重入锁</span><br><span class="line"> </span><br><span class="line">public void test()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        doSomeThing();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        // ignored</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="aqs">AQS</span></h2><p>AbstractQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。</p>
<p>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。如图</p>
<p><img src="aqs.png" alt=""></p>
<p>AQS中还有一个表示状态的字段state，例如ReentrantLock用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。</p>
<p>AbstractQueuedSynchronizer继承了AbstractOwnableSynchronizer，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。</p>
<p>理解AQS可以帮助我们更好的理解JCU包中的同步容器。</p>
<h2><span id="lock的类型">lock的类型</span></h2><p>可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。<br>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。<br>公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。<br>CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h1><h2><span id="from-oracle">from oracle</span></h2><p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</p>
<p>This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don’t want to synchronize traversals, yet need to preclude interference among concurrent threads. </p>
<h2><span id="from-google-serach">from google serach</span></h2><p>This is a very useful construct in the multi-threaded programs – when we want to iterate over a list in a thread-safe way without an explicit synchronization.</p>
<p>When we are using any of the modify methods – such as add() or remove() – the whole content of the CopyOnWriteArrayList is copied into the new internal copy.</p>
<h2><span id="when-to-use-it">when to use it</span></h2><p>dont want to synchronize the traversal operations </p>
<h2><span id="diff-with-readwritelock">diff with  ReadWriteLock</span></h2><p>CopyOnWriteArrayList is for safe traversals.</p>
<p>ReadWriteLock would allow multiple readers and still let the occasional writer perform the necessary modifications. </p>
<h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.ConcurrentModificationException;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class CopyOnWriteArrayListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList = new ArrayList&lt;&gt;();</span><br><span class="line">        empList.add(&quot;yifan&quot;);</span><br><span class="line">        empList.add(&quot;guo&quot;);</span><br><span class="line">        empList.add(&quot;smith&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; empIter = empList.iterator();</span><br><span class="line"></span><br><span class="line">        while(empIter.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(empIter.next());</span><br><span class="line">                if (!empList.contains(&quot;lala&quot;)) empList.add(&quot;lala&quot;);</span><br><span class="line">            &#125; catch (ConcurrentModificationException cme) &#123;</span><br><span class="line">                System.err.println(&quot;attempt to modifiy list during iteration&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; empList2 = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        empList2.add(&quot;yifan&quot;);</span><br><span class="line">        empList2.add(&quot;guo&quot;);</span><br><span class="line">        empList2.add(&quot;smith&quot;);</span><br><span class="line">        empIter = empList2.iterator();</span><br><span class="line">        while (empIter.hasNext()) &#123;</span><br><span class="line">            System.out.println(empIter.next());</span><br><span class="line">            if (!empList2.contains(&quot;Tom Smith&quot;))</span><br><span class="line">                empList2.add(&quot;Tom Smith&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="transient">transient</span></h1><p>The transient keyword in Java is used to indicate that a field should not be serialized.</p>
<h2><span id="demo">demo</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class demo implements Serializable &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private transient String middleName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public demo (String fName, String mName, String lName)&#123;</span><br><span class="line">        this.firstName = fName;</span><br><span class="line">        this.middleName = mName;</span><br><span class="line">        this.lastName = lName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(40);</span><br><span class="line">        sb.append(&quot;First Name : &quot;);</span><br><span class="line">        sb.append(this.firstName);</span><br><span class="line">        sb.append(&quot;Middle Name : &quot;);</span><br><span class="line">        sb.append(this.middleName);</span><br><span class="line">        sb.append(&quot;Last Name : &quot;);</span><br><span class="line">        sb.append(this.lastName);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        demo nameStore = new demo(&quot;Steve&quot;, &quot;Middle&quot;,&quot;Jobs&quot;);</span><br><span class="line">        ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;nameStore&quot;));</span><br><span class="line">        // writing to object</span><br><span class="line">        o.writeObject(nameStore);</span><br><span class="line">        o.close();</span><br><span class="line"></span><br><span class="line">        // reading from object</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;nameStore&quot;));</span><br><span class="line">        demo d = (demo)in.readObject();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="reentrant-lock-可重入锁">Reentrant lock (可重入锁）</span></h1><p>synchronized 也是可重入锁</p>
<p>2.可中断锁</p>
<p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p>
<p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p>
<p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>　　3.公平锁</p>
<p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p>
<p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p>
<p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p>
<p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。设置方法如下：ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);</p>
<h1><span id="readwritelock">ReadWriteLock</span></h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/concurrency/" rel="tag"># concurrency</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/26/JVM01/" rel="next" title="Java Virtual Machine Learning Notes">
                <i class="fa fa-chevron-left"></i> Java Virtual Machine Learning Notes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/29/vertx-io/" rel="prev" title="vertx.io">
                vertx.io <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpeg"
                alt="Yifan Guo" />
            
              <p class="site-author-name" itemprop="name">Yifan Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">Java Concurrent Package API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">JUC结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">AQS (abstractQueuedSynchronizer)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">Latch (闭锁）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">6.1.</span> <span class="nav-text">await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">6.2.</span> <span class="nav-text">countDown()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">Unsafe instances</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">7.1.</span> <span class="nav-text">锁不一致</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">ConcurrentMap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">ConcurrentModificationException</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">10.</span> <span class="nav-text">Operating System</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">11.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">12.</span> <span class="nav-text">thread security</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">13.</span> <span class="nav-text">三种同步方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">14.</span> <span class="nav-text">NIO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">15.</span> <span class="nav-text">Context Switch （上下文切换）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">16.</span> <span class="nav-text">同步机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">17.</span> <span class="nav-text">intrinsic lock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">18.</span> <span class="nav-text">private lock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">19.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">20.</span> <span class="nav-text">publish and escape</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">21.</span> <span class="nav-text">线程封闭 threadlocal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">22.</span> <span class="nav-text">final and Private</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">23.</span> <span class="nav-text">CAS-compareAndSwapInt</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">24.</span> <span class="nav-text">memory barrier</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">25.</span> <span class="nav-text">Bus locking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">25.1.</span> <span class="nav-text">from Intel Manual, Volume 3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">26.</span> <span class="nav-text">Unsafe</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">27.</span> <span class="nav-text">native</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">28.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">28.1.</span> <span class="nav-text">CAS缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">28.2.</span> <span class="nav-text">Is multi-threading really worth it?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">28.3.</span> <span class="nav-text">context switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">28.4.</span> <span class="nav-text">single thread vs multi threads</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">29.</span> <span class="nav-text">synchronized (可重入锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">29.1.</span> <span class="nav-text">locks in synchronized methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">29.2.</span> <span class="nav-text">重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">29.3.</span> <span class="nav-text">Reentrant Synchronization</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">30.</span> <span class="nav-text">synchronized和lock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">30.1.</span> <span class="nav-text">synchronized 的局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">30.2.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">30.3.</span> <span class="nav-text">lock使用方式，需要手动释放锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">30.4.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">30.5.</span> <span class="nav-text">lock的类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">31.</span> <span class="nav-text">CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">31.1.</span> <span class="nav-text">from oracle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">31.2.</span> <span class="nav-text">from google serach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">31.3.</span> <span class="nav-text">when to use it</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">31.4.</span> <span class="nav-text">diff with  ReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">31.5.</span> <span class="nav-text">demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">32.</span> <span class="nav-text">transient</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">32.1.</span> <span class="nav-text">demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">33.</span> <span class="nav-text">Reentrant lock (可重入锁）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">34.</span> <span class="nav-text">ReadWriteLock</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan Guo</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">22.3k</span>
  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.yifanguo.top/2018/07/27/concurrency/';
          this.page.identifier = '2018/07/27/concurrency/';
          this.page.title = 'Java Concurrent Package API';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://www-yifanguo-top.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

  
</body>
</html>
